---
title: "Trend Viewer"
author: "jp"
date: "1/4/2021"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
runtime: shiny
---

```{r setup, include=FALSE}
options(shiny.trace=FALSE)
library(shiny)
knitr::opts_chunk$set(echo = FALSE)
source( "data_time_libraries.r")

library(pacman)

pacman::p_load( officer , rvg ,
                tidyverse, scales, plotly ,
                data.table , tidyfast, tidytable ,
        lubridate , anytime, progressr , assertthat  , stringr, 
        readxl, patchwork, cowplot, kableExtra  ,
        tsibble, fable, fabletools, feasts  , 
        fable.prophet ,  #fable.bsts  , 
        slider, anomalize, brolgar   ,
        tsbox , CausalImpact , tibbletime , dygraphs  , 
        fpp3  , fabletools  , 
        furrr, tictoc, magrittr, hrbrthemes, data.tree, igraph  ,
        sf, mapview, GGally , plotly , sugrrants, lemon , plotly ,
        shinyscreenshot, ggrepel
        )

options( dplyr.summarise.inform = FALSE )

## Functions ####
source( "ingest_formula_data.r")
source( "formula_files.r" )
source( "clean_ts.r" )
source( "outlier.r" )
source( 'Deviation_Expected_Functions.R')

most_recent_file = function( file_list_with_date , mark = 3 ){
  rdsFileSplit = str_split( file_list_with_date, "_")
  # download_date = map( rdsFileSplit ,
  #                      ~str_split( .x[ length(.x)] , "\\.")[[1]]
  # ) %>% map_chr(1) 
  
  download_date = map_chr( rdsFileSplit ,
                       ~.x[which( grepl( fixed("-") , .x ) )] )
  
  dates  = map_chr( download_date , ~ anydate(.x)  )
  
  if ( identical( dates , character(0) ) ) return( NA )
  
  # most recent file 
  file = file_list_with_date[ which( dates == max(dates, na.rm = T ) ) ]
  
  return ( file )
}


Month_Year = function( x ){ yearmonth( zoo::as.yearmon( x , "%Y%m") ) }

files = function(  search = 'All' , type = 'xlsx' , other = "" , directory = NULL ){
                        
                      dir.files = list.files( directory )
                      search_and_type =  
                          str_detect( dir.files, fixed( search , ignore_case=TRUE )  )  &
                           grepl( paste0( type , '$' ) , dir.files, 
                                  ignore.case =  TRUE  ) &
                          grepl( other , dir.files , ignore.case = TRUE ) 
                      files = dir.files[  search_and_type   ]
                      return( files[ rev( order( files )) ]  )
                      }

file.dir = function( country = NULL ,
                     dir.base = '../dataDictionary/dhis2_dictionary/Formulas/' ){
  
  has.slash.at.end = str_locate_all( dir.base , "/") %>% 
    unlist %in% nchar( dir.base) %>% any 
  if ( !has.slash.at.end  ){ dir.base = paste0( dir.base , "/" ) }
  paste0( dir.base , country , "/" )

}


# see https://stackoverflow.com/questions/54438495/shift-legend-into-empty-facets-of-a-faceted-plot-in-ggplot2
shift_legend2 <- function(p) {
  # ...
  # to grob
  gp <- ggplotGrob(p)
  facet.panels <- grep("^panel", gp[["layout"]][["name"]])
  empty.facet.panels <- sapply(facet.panels, function(i) "zeroGrob" %in% class(gp[["grobs"]][[i]]))
  empty.facet.panels <- facet.panels[empty.facet.panels]

  # establish name of empty panels
  empty.facet.panels <- gp[["layout"]][empty.facet.panels, ]
  names <- empty.facet.panels$name
  # example of names:
  #[1] "panel-3-2" "panel-3-3"

# now we just need a simple call to reposition the legend
  reposition_legend(p, 'center', panel=names)
}

shift_legend3 <- function(p) {
    pnls <- cowplot::plot_to_gtable(p) %>% gtable::gtable_filter("panel") %>%
      with(setNames(grobs, layout$name)) %>% purrr::keep(~identical(.x,zeroGrob()))

    if( length(pnls) == 0 ) return(p)

    lemon::reposition_legend( p, "center", panel=names(pnls) )
}


```


```{css my-css, echo = FALSE}
# .chart-title {
#     font-size: 48px;
# }
.tab-content {
  overflow: visible;
}
.selectize-control .selectize-dropdown {
  position: static !important;
}
.select-control .select-dropdown {
  position: static !important;
}

/* Customize fonts */
body, label, input, button, select { 
  font-family: 'Helvetica Neue', Helvetica;
  font-weight: 200;
}
h1, h2, h3, h4 { font-weight: 400; }

#controls {
  /* Appearance */
  background-color: white;
  padding: 0 20px 20px 20px;
  cursor: move;
  /* Fade out while not hovering */
  opacity: 0.65;
  zoom: 0.9;
  transition: opacity 500ms 1s;
  overflow-y: auto;
}

#controls:hover {
  /* Fade in while hovering */
  opacity: 0.95;
  transition-delay: 0;
}
```

Inputs {.sidebar data-width=300}
====================================

```{r input, echo=FALSE}
inputPanel(
  
  
selectInput("Admn2", label = "Admn2" , 
              choices = NULL, 
              selected = NULL ,
              multiple = TRUE ) ,

selectInput("Admn3", label = "Admn3" ,
              choices = NULL,
              selected = NULL ,
              multiple = TRUE ) ,

selectInput("Admn4", label = "Admn4" ,
              choices = NULL,
              selected = NULL  ,
              multiple = TRUE  ) ,
  
  selectInput("data", label = "DataElement/Category" , 
              choices = NULL , 
              selected = 1 ,
              multiple = TRUE , selectize = TRUE ) ,
  
  checkboxInput( "total", label ='Total all categories', value = FALSE ) ,
  
  # checkboxInput( "merge", label ='Merge datasets', value = FALSE ) ,
  selectInput( "merge", label ='Merge datasets', 
               choices = NULL , selected = NULL ,
               multiple = TRUE , selectize = TRUE ) ,
  
  checkboxInput( "dataset", label ='Total unmerged datasets', value = TRUE ) ,
  
  selectInput("source", label = "Original/Cleaned" , 
              choices = c( 'Original', 'Cleaned' ) , 
              selected = 'Original' ) ,
  
  selectInput("split", label = "Split Data By:" , 
              choices = "None" , 
              selected = "None" ) , 
  
  checkboxInput( "count.any", label ='Count any categories', value = FALSE ) ,
  
  checkboxInput( "mostReports", label ='Most frequently reporting facilities', value = FALSE ) ,
  
  textInput( "startingYear", label = "begining with", value = "2017" ) ,
  
  actionButton( "screenshot" , "Screenshot" ) ,
  
  selectInput("shotSelection", label = "Screenshot Chart:" , 
              choices = c(NULL, 
                          'plot_reporting_by_month', 
                          'plot_reports_in_a_year', 
                          'map' , 
                          'plot_values' ,
                          'plot_trends'),
              selected = NULL ) 
  # checkboxInput( 'calendar_year', "Calendar Year" , value = TRUE )
)

# testing 
# country = "Burkina Faso"
# indicator = "ANC"
# exclude_recent_month = TRUE


```

```{r screenshot}

observeEvent( input$screenshot , {
  screenshot.file = filename = paste(input$country,
                                     input$indicator, 
                                     input$shotSelection,
                                     sep="_"  )
  print( paste(
    'Screenshot saved to:' , screenshot.file 
  ))
  
  screenshot( id = input$shotSelection, 
              filename = screenshot.file ,
              scale = 8
  )
})
```

```{r Formulas }


data.folder = reactive({
  print( 'data.folder:')
  req( input$country )
  req( input$data.directory  )
  data.folder = file.dir( country = input$country , dir.base = input$data.directory )
  print( 'data.folder is '); print( data.folder )
})

formula.file = reactive({ 
  req( data.folder() )

  ff = paste0( data.folder() , 
          files( search = 'Formula' , directory = data.folder() )  %>% 
            most_recent_file() 
          )
  
  print( 'formula.file' ) ; print( ff )
  return( ff )
  })

formulas =  reactive({
  req( formula.file() )

  print( 'formula file') ; print( formula.file() )
  
  if ( !any(file.exists( formula.file() ) )) return( NULL )
  formulas = read_excel( formula.file() , sheet = 'Formula') %>% 
    filter( !is.na(Formula.Name)) %>%
    arrange( Formula.Name )
  
  print( 'formulas') ; print( formulas$Formula.Name )
  
  return( formulas )
})

formula.names = reactive({ formulas()$Formula.Name })

formula_elements =  reactive({
  req( formula.file() )
  req( input$indicator )
  
  read_excel( formula.file() , sheet = 'Formula Elements')  %>%
    filter( Formula.Name %in% input$indicator )

})

observe({  updateSelectInput( session, 'indicator' , 
                              choices =  formula.names() ,
                              selected = NULL ) } )

observe({  updateSelectInput( session, 'split' , 
                              choices =  c('None', names( dataset() )) ) } )

observe({  updateTextInput( session, 'startingYear' , 
                            value  =   min( d() %>% 
                                   pull( !! rlang::sym( period() ) ) %>%
                                     year ))  
  })

```

```{r d}

observe({
  req( input$data.directory  )
  if ( dir.exists( input$data.directory ) ){ 
    data.dirs = input$data.directory
    print( 'updating country folder' )
    updateSelectInput( session, 'country' , 
                       choices =  list.dirs( data.dirs , recursive=FALSE) %>%
                         basename
    )
  }
} )


country_files = reactive({ 

  
    if ( !dir.exists( data.folder() )) return( NULL )
    dir.files = list.files( data.folder() )
    print( "dir.files : "); # print( dir.files )
    return( dir.files )
})
  
rds_data_file = reactive({
  req( country_files() )
  req( data.folder() )
  req( input$indicator )
    
  dir.files = country_files()

  indicator = paste0( "_" , input$indicator , "_" )
  print( 'indicator:' ); print( input$indicator )
  
  file.type = 'rds' # input$file.type 
  file.other = 'Seasonal' # input$file.other
  file.label = 'formulaData'
  
  all.levels.data.files = dir.files[ grepl( 'All levels' , dir.files) &
          grepl( file.type , dir.files) &
          grepl( file.other, dir.files, fixed = TRUE  ) &
          grepl( file.label, dir.files, fixed = TRUE  )]

  print('all levels data files:') ; print( all.levels.data.files )
  
  f.indicator = grepl( indicator , all.levels.data.files , fixed = TRUE )
  
  print("f.indicator:" ) ;  print( f.indicator ) 
  
  if ( sum( f.indicator ) == 0 ) return( NULL )
  
  if ( !dir.exists( data.folder() )) return( NULL )
  
  data_file = paste0( data.folder() , all.levels.data.files[f.indicator]  )  # %>% most_recent_file()
  
  print( 'data_file is'); print( data_file )
  
  if ( !any(file.exists( data_file ))) return( NULL )

  print( "data file exists =" ); print( any(file.exists( data_file )) )
  return( data_file )

})

xlxs_data_file = reactive({
  req( country_files() )
  req( input$indicator )

  dir.files = country_files()

  indicator = input$indicator
  print( 'indicator:' ); print( input$indicator )

  file.type = 'xlxs' # input$file.type
  file.other = '' # input$file.other

  all.levels.data.files = dir.files[ grepl( 'All levels' , dir.files) &
                                       grepl( file.type , dir.files) &
                                       grepl( file.other, dir.files, fixed = TRUE  )]

  print('all levels data files:') ; print( all.levels.data.files )

  f.indicator = grepl( indicator , all.levels.data.files , fixed = TRUE )
  print("f.indicator:" ) ;  print( f.indicator )

  if ( sum( f.indicator ) == 0 ) return( NULL )

  if ( !dir.exists( dir() )) return( NULL )

  data_file = paste0( dir() , all.levels.data.files[f.indicator]  )  %>% most_recent_file()

  if ( !file.exists( data_file )) return( NULL )

  print( "data file:" ); print( data_file )
  return( data_file )

})

# updateSelectInput( "indicator", choices = )

dataset = reactive({
  print( 'dataset():')
  req( rds_data_file() )
  
  print("ingesting..."); 
  showNotification( "reading data file", type = 'message' )
  
  if ( is.null( rds_data_file() ) ) return( NULL )
  
  print( rds_data_file() )

  # testing:
  tic()
  if ( !any(file.exists( rds_data_file() ))) return( NULL )
  
  # RDS 
  dataset =  readRDS( rds_data_file() ) 
  
  print( "nrow( dataset )" ); print( nrow( dataset ) )
  print( "add dataset info from formulas")
  
  dataset = dataset %>%
    as_tibble() %>%
    left_join( formula_elements() %>% 
                 select( dataElement.id  , dataSet ) %>%
                 distinct ,  
               by = 'dataElement.id' )
  
  print( "nrow( dataset )" ); print( nrow( dataset ) )
  print("done"); toc()
  print( 'glimpse( dataset )' ); # glimpse( dataset )
  #   glimpse( formula_elements() )
    
  return( dataset )
  
})

dataSets = reactive({
  req( dataset() )
  dataset() %>% filter( !is.na( dataSet ) ) %>%
            pull( dataSet ) %>% unique
})

observe({
  print( 'updating datasets' )
  req( dataSets() )
  if ( any( nchar( dataSets() > 0 ) ) ){ 
    updateSelectInput( session, 'merge' , 
                       choices =  dataSets() 
    )
  }
} )

most_recent_period = reactive({
  req( period() )
  print( 'most_recent_period' ); print( period() )
  print( names( dataset() ))
  mrp = max( dataset() %>% 
               pull( !! rlang::sym( period() ) ), na.rm = TRUE ) 
  # mrp = max( dataset()[ , 'Month'] , na.rm = TRUE ) 
  # mrp = max( dataset()$Month , na.rm = TRUE ) 
  print( 'most recent period is'); print( mrp )
  
  # if ( input$exclude_recent_month ){
  #   if ( period() == "Month" ) mrp = mrp - month(1)
  #   if ( period() == "Week" ) mrp = mrp - week(1)
  # } 
  
  print( 'mrp:') ; print(mrp)
  return( mrp )
})

period = reactive({
  print('period():')
  req(dataset())

  weekly = any( map_lgl( dataset() , 
                         ~any(class(.x) %in% 'yearweek'  )) )
  
  period = ifelse( weekly, "Week", "Month" )
  print('end period()'); print( period )
  return( period  )
})

observe({
  print( 'updating data_choices' )
  updateSelectInput( session, 'data' , 
                     choices =   unique( dataset()$data ) ,
                     selected = 1 ) 
} )


d = reactive({

  req( dataset() )
  req( period() )
  print( 'd:')
  
  data = dataset()  
  .period = period()
  
  if ( !is_empty( input$Admn2 ) ){
    print( paste( 'filtering data by' , levelNames()[2] , "=" , input$Admn2 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[2])  %in%   input$Admn2  )
    
    print( paste( 'data filtered by Admn2 has' , nrow( data ), 'rows' ))
    # glimpse( data )
  }
  
    if ( !is_empty( input$Admn3 ) ){
    print( paste( 'filtering data by' , levelNames()[3] , "=" , input$Admn3 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[3])  %in%   input$Admn3  )
    
    print( paste( 'data filtered by Admn3 has' , nrow( data ), 'rows' ))
    # glimpse( data )
    }
  
if ( !is_empty( input$Admn4 ) ){
    print( paste( 'filtering data by' , levelNames()[4] , "=" , input$Admn4 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[4])  %in%   input$Admn4  )
    
    print( paste( 'data filtered by Admn4 has' , nrow( data ), 'rows' ))
    # glimpse( data )
  }
  
  print( 'nrow( d )' ); print( nrow( data ))
  
  if ( input$level %in% 'leaf'){  
    data = data %>% filter( effectiveLeaf == TRUE )
  } else {
    data = data %>% filter( levelName  %in% input$level  )
  }
  
  # if ( input$exclude_recent_month ) data = data %>% 
  #   filter( !! rlang::sym( period() ) <= most_recent_period() )
  
  if ( input$source %in% 'Original' ){
    data = data %>% mutate( dataCol = original )
  }  
  
  if ( input$source %in% 'Cleaned' ){
    print( paste('cleaning removes', sum( data$value , na.rm = T ) - sum( data$seasonal3 , na.rm = T )  , 'data points' ) )
    data = data %>% mutate( dataCol = ifelse( seasonal3, original, NA  ) )

    print( paste('cleaning changes total by', sum( data$original , na.rm = T ) - sum( data$dataCol , na.rm = T )) )
  }  
  
  # print( 'd: max period ' ); print( max( d$period ))
  print( 'd: max period ' ); 
  print( max( data %>% pull( !! rlang::sym( .period )  ) , 
              na.rm = TRUE ))
  # print( max( data$Month , na.rm = TRUE ))
  
  # Modify variables used for cleaning data so that FALSE when NA -- meaning it failed prior cleaning step, and TRUE means data is ok
  if ('mad15' %in% names( data )) data = data %>% mutate( mad15 = ifelse( value & is.na( mad15)|!mad15, FALSE, TRUE ) )
  if ('mad10' %in% names( data )) data = data %>% mutate( mad10 = ifelse( value & is.na( mad10)|!mad10, FALSE, TRUE ) )
  if ('mad5' %in% names( data )) data = data %>% mutate( mad5 = ifelse( value & is.na( mad5)|!mad5, FALSE, TRUE ) )
  if ('seasonal5' %in% names( data )) data = data %>% mutate( seasonal5 = ifelse( value & is.na( seasonal5)|!seasonal5, FALSE, TRUE ) )
  if ('seasonal3' %in% names( data )) data = data %>% mutate( seasonal3 = ifelse( value & is.na( seasonal3)|!seasonal3, FALSE, TRUE ) )
    
  print( 'end d()' )
  return( data )
})


```



Data
===================================

```{r}
# inputPanel(
splitLayout( 
  textInput( "data.directory", label = "Data directory:", 
             value = "../dataDictionary/dhis2_dictionary/Formulas/" ,
             width = '100%'
             # , style = "font-size: 50%;"
             ) 
  ) 

 
  selectInput("country", label = "DHIS2 instance (Country) Folder:" , 
              choices = NULL 
              ) 
  
 selectInput("level", label = "Organization Level:" ,
              choices = c( 'leaf' ) ,
              selected = NULL ) 
 
 checkboxInput('hts', label = "Use administrative hierarchy", 
               value = TRUE ) 
  
 selectInput("indicator", label = "Indicator:" , 
              choices = NULL , 
              selected = FALSE,
              multiple = FALSE ,
              selectize = FALSE, 
              size = 4  ##needed for `selected = FALSE` to work ) 
)
 
splitLayout( 
  textInput( "data.intervention", label = "Data intervention:", 
             value = "" ,
             width = '100%'
             # , style = "font-size: 50%;"
             ) ,
  
  selectInput("intervention.key", label = "Intervention key:" , 
              choices = NULL , 
              selected = NULL ) 
  
)

  checkboxInput( "exclude_recent_month" , label ='Exclude most recent month?',
               value = TRUE  ) 
```


Reporting 
====================================

Row 
-------------------------------------

```{r data.reports}


orgunit.reports = reactive({ 
  req( input$data )
  req( most_recent_period() )
  req( period() )
  
  print( 'orgunit.reports()' )
  
  mrm = most_recent_period()
  
  year_var = 'calendar_year' # ifelse( input$calendar_year , 'calendar_year' , 'months12' )
  
  data = d()
  
  if ( !input$count.any & !input$total  )  data = 
    data %>% filter( data %in% input$data )
    
  .period = period()

  o.r. = 
    data %>% as_tibble() %>% ungroup %>%
    
    mutate(

    calendar_year = year( !! rlang::sym( .period )  )
     
  ) %>%
  rename( year =  {{ year_var }} ) 
  
    
  o.r. = setDT(o.r.)[, .( n_periods = uniqueN( get( .period ) )), 
                   by = c( 'year' , 'orgUnit' ) ] %>%
    as_tibble() %>%
  # group_by( year , orgUnit ) %>%
  # summarise( n_periods = n_distinct( !! rlang::sym( period() )  ) 
  #            # , max_month = max( Month ) 
  #            ) 
  mutate( n_periods = factor( n_periods ) ,
          year = factor( year ) )
  
  #print( 'o.r:') ; # print(head(o.r))
  print( 'end orgunit.reports' )
  return(o.r.)
})

annual.reports = reactive({ 
  req( orgunit.reports() )
  print( 'annual reports()' )
  
  or = orgunit.reports() 
  # print( 'annual reports() or:' ); print( names(or))
  
  ar = setDT(or)[, .( n = .N ), 
                   by = c( 'year' , 'n_periods' ) ] %>%
    as_tibble()
  
  # group_by( year ,  n_periods ) %>%
  # summarise( n = n() )
  print( 'end annual reports' )
  return( ar )
})

orgunit.monthly.reports = reactive({ 
  req( input$data )
  print( 'orgunit.monthly.reports' )
  
  # mrp = most_recent_period()
  .period = period()
  
  year_var = 'calendar_year' # ifelse( input$calendar_year , 'calendar_year' , 'months12' )
  
  data = d()
  
  if ( !input$count.any & !input$total   ) data = data %>% filter( data %in% input$data )
  
  o.m.r = 
    data %>% as_tibble() %>% ungroup %>%

    mutate(
           calendar_year = year( !! rlang::sym( .period )  )
     
  )  %>%
  rename( year =  {{ year_var }} ) 
  # %>%
  # mutate( year = factor( year ) )

  print( 'end orgunit.monthly.reports' )
  # print(head(o.m.r))
  return(o.m.r)
})

monthly.reports = reactive({ 
  req( orgunit.monthly.reports() )
  req( period() )
  print( 'monthly reports()' )
  
  .period = period()
 
  o.m.r = orgunit.monthly.reports() 
  
  # print('monthly.reports() o.m.r'); print( names(o.m.r) )
  
  m.r = setDT(o.m.r)[, .( n = uniqueN( orgUnit ) ), 
                   by = c( "year" , .period  ) ]  %>%
    as_tibble()
  
  # group_by( year , !! rlang::sym( .period )   ) %>%
  # summarise( n = n_distinct( orgUnit ) )
  
  # print('m.r') ; glimpse(m.r)
  print( 'end monthly reports()' )
  # glimpse( m.r)
  return(m.r)
})


facilities = reactive({
  print( 'facilities' )
  req( orgunit.reports() )
  
  f = orgunit.reports() %>%
  ungroup() 
  
  f = setDT(f)[, .( Total = uniqueN( orgUnit ))] %>%
    as_tibble() %>%
    # summarise( Total = n_distinct( orgUnit ) ) %>%
    pull( Total)
  
  print( 'end facilities' )
  return(f)
})

```

```{r selectedOus }

selected <- reactiveValues( x  = NULL, panel = NULL , chart = NULL )

observeEvent( input$plot1_brush  , {
  # glimpse( input$plot1_brush )
  selected$chart = 1
  
  selected$x = round( 
    seq( input$plot1_brush$xmin , input$plot1_brush$xmax , by = .5 )
  ) %>% unique 
  
  selected$panel = input$plot1_brush$panelvar1
      
  print( "plot1 selected$x:" ) ;  print( paste( selected$x , selected$panel ) )
  return( selected )
})

observeEvent( input$plot2_brush  , {
  # glimpse( input$plot1_brush )
  selected$chart = 2
  
  selected$x = round( 
    seq( input$plot2_brush$xmin , input$plot2_brush$xmax , by = .5 )
  ) %>% unique %>% as.integer()
  
  selected$panel = input$plot2_brush$panelvar1
      
  print( "plot_2_selected$x:" ) ;  print( selected$x ) ; print( selected$panel ) 
  return( selected )
})

selectedOUs <- reactive({
  print( 'selectedOUS()' )
  tic()
  req( input$startingYear )
  
  if ( input$mostReports ){
     print( "determining most frequently reported facilities..." ); 
    
    data = d()
    
    if ( !input$count.any & !input$total  ){
        print( input$total )
        data = data %>% filter( data %in% input$data )
     }

     mr = data %>% as_tibble %>%
       filter( year( !! rlang::sym( period() )  ) >= as.integer( input$startingYear ) ) %>% 
       distinct( !! rlang::sym( period() ) , orgUnit ) %>%
       group_by( orgUnit ) %>%
       summarise( n = n() ) %>%
       arrange( desc( n ))
     
     print( "mr" ); print( summary( mr$n ) )

     s = mr %>%
       filter( n == max( mr$n ) ) %>%
       pull( orgUnit ) %>% unique
     
     print( "mostReports selectedOUs:" ); toc() ##print( selectedOUs )
     return( s )
     }
  
  if( is.null( selected$x ) ) return( NULL )
  
  if ( selected$chart == 1 ){
      select_month =  as.numeric( orgunit.reports()$n_periods ) %in% selected$x
      selectedRows = select_month &
         orgunit.reports()$year %in% selected$panel 
      s = orgunit.reports()[ selectedRows, ]$orgUnit %>% unique
      
      

    } else {
      select_month = month( orgunit.monthly.reports() %>%
                              pull( !! rlang::sym( period() ) ) ) %in% selected$x
      selectedRows = select_month &
        year( orgunit.monthly.reports() %>%
                pull( !! rlang::sym( period() ) ) ) %in% selected$panel
      s = orgunit.monthly.reports()[ selectedRows, ]$orgUnit %>% 
        unique
      
      
    }

      print( "end selectedOUs:" ); toc()  # print( selectedOUs )
      return( s )
    })
  
x.annual = reactive({
  print( 'x.annual()' )
  tic()
  x.a = orgunit.reports() %>% 
        filter( orgUnit %in% selectedOUs() )   # %>%  
        # group_by( year , n_periods ) %>%
        #   summarise( n =  n_distinct( orgUnit ) )
  
  # data.table speed up over dplyr
  x.a = setDT(x.a)[, .( n = uniqueN( orgUnit )), 
                   by = c( 'year' , 'n_periods' ) ]  %>%
    as_tibble()

  print('end x.annual:') ; toc();  # print( x.a )
  return( x.a )
  
})

x.months = reactive({
  # req( keeprows() )
  tic()
  print( 'x.months()' )
  
  .period = period()
  
  x.m = orgunit.monthly.reports() %>% 
        filter( orgUnit %in% selectedOUs() ) 
  
  x.m = setDT(x.m)[, .( n = uniqueN( orgUnit )), 
                   by = c( 'year' , .period )   ]  %>%
    as_tibble()
  
  
  # %>%
  #       group_by( year , !! rlang::sym( period() )  ) %>%
  #       summarise( n = n_distinct( orgUnit ) )
  
  print('end x.months:') ; toc() ; # glimpse( x.m )
  return( x.m )
  
})


```
  

### Number of Facilties Reporting each Period (plot_reporting_by_month)

```{r}
plotOutput( 'plot_reporting_by_month' , 
    click = "plot2_click" ,
    dblclick = "plot2_dblclick" ,
    hover = "plot2_hover" ,
    brush = "plot2_brush" )

```


```{r plot_reporting_by_month }

plot2 = reactive({
  req( monthly.reports() )
  print('plot2')
  .period = period()
  
  # save data for testing ggplot options
  saveRDS( monthly.reports(), 'plot2_data.rds' )
  
  if ( length( monthly.reports()$year) > 0  ) {
  
  if ( .period == "Month" ){
            .breaks = 1:12
  } else {
            .breaks = seq(2, 53, 4)
  }

  g = ggplot( monthly.reports() %>% mutate( facilities = 'All' ), 
              aes( x =  !! rlang::sym( .period ) 
                   , y = n  
                   , group = facilities
                   , color = facilities 
                   ) ) +
    # geom_col() +
    geom_point( ) +
    geom_line( ) +
    geom_hline( yintercept = facilities() ) +
    facet_wrap( ~ year , scales = 'free_x') +
    # scale_x_discrete( .period 
    #                     , breaks = .breaks
    #                     # , labels  = as.character( .breaks )
    #                     )  +
    ylim( 0 , NA ) +
    scale_color_manual( values = c( 'All' = 'black' , 
                                    'Selected'= 'brown' ) ) +
    scale_fill_manual( values = c( 'All' = 'black' , 
                                    'Selected'= 'brown' ) ) 

  if (!is.null( selectedOUs() ) ){
    g = g + 
      # geom_col(  data = x.months() %>% mutate( facilities = 'Selected' )  ) 
      geom_point( data = x.months() %>% mutate( facilities = 'Selected' ) ) +
      geom_line( data = x.months() %>% mutate( facilities = 'Selected' ) )
    }
  
  return( shift_legend3(g) )
  # return( g )
  }
  
  print('end plot2')
  return( g )
})

output$plot_reporting_by_month <- renderPlot({  plot2()  })

```



```{r plot_brush, eval = FALSE }

verbatimTextOutput("info")

output$info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             " ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }

    paste0(
      "click: ", xy_str( input$plot1_click ),
      "dblclick: ", xy_str(input$plot1_dblclick),
      "hover: ", xy_str(input$plot1_hover),
      "brush: ", xy_range_str(input$plot1_brush)
    )
  })

```


```{r html_text, eval=FALSE }

htmlOutput("x_value")
      
```


```{r selected_text}

 # Print the name of the x value
  output$x_value <- renderText({
    
    if ( input$mostReports ){ 
      HTML("You've selected <code>" , comma( length( selectedOUs() ) ), "facilities" , 
           "</code>" )
    }
    
    if ( is.null( selected$x ) ) return("")
    
    else {
      lvls <- levels( annual.reports()$n_periods )
      panel = selected$panel
      
      name <- lvls[ round( selected$x ) ]
      HTML("You've selected <code>" , comma( length( selectedOUs() ) ) , 
           "</code>" ,
           "facilities that submitted data for <code>", 
           paste( name, collapse = "," ) , 
           "months during", panel , 
           "</code>" )
    }
  })

```

### Histogram of Annual Number of Months Reported (plot_reports_in_a_year)

```{r}
plotOutput( 'plot_reports_in_a_year' , 
    click = "plot1_click" ,
    dblclick = "plot1_dblclick" ,
    hover = "plot1_hover" ,
    brush = "plot1_brush" )

```

```{r plot1 }

plot1 = reactive({
  print( 'plot1' )
  req( annual.reports() )
  req( period() )
  .period = period()
  
  # save data for testing ggplot options
  saveRDS( annual.reports() , 'plot1_data.rds' )
  
  
  if ( length( annual.reports()$year) > 0  ) {
    
  if ( .period == "Month" ){
            .breaks = 1:12
  } else {
            .breaks = seq(2, 53, 4)
  }
    
  g = ggplot( annual.reports() , 
              aes( x = n_periods , y = n ) ) +
    geom_col() + 
    scale_x_discrete( 'Number Months Reported' 
                      , breaks = .breaks   
                      , labels  =  .breaks
                      )  +
    geom_hline( yintercept = facilities() ) +
    facet_wrap( ~ year , scales = 'free_x')
  
  if (!is.null( selectedOUs() ) ){
    g = g + geom_col( data = x.annual() , fill = 'brown' ) 
  }

  print( 'end plot1' )
  return(g)
  }
})

output$plot_reports_in_a_year <- renderPlot({  plot1()  })

```

Row 
-------------------------------------
  

### Values (plot_values)


```{r plotAgregateValue  }

plotOutput( 'plot_values' ,
    hover = "plotSelectedOusValues_hover" ,
    brush = "plotSelectedOusValues_brush"
    )

plotData = reactive({
   print( 'plotData()')
   req( d() )
   req( input$data )
  
    data = d() %>%
      mutate( Facilities = 'All' )
    
    # filter to selected category
    print( 'plotData filtered by' ); print( input$data )

    if ( !input$total )  data = data %>% filter( data %in% input$data )
    
    # Add var for selected ous
    print( 'length( selectedOUs()) ' ); print( length( selectedOUs())  )
    
   if ( length( selectedOUs()) > 0 ) data  = data %>%
      mutate( Facilities = ifelse( 
        orgUnit %in% selectedOUs() , 'Selected', 'Not selected' )
      )
    
    # compare original and cleaned
    # print( paste('original - dataCol = ', sum( data$original , na.rm = T ) - sum( data$dataCol , na.rm = T )) )
  
    print( 'end  plotData()')  ; # print( names( data )) 
  return( data )
})

group_by_cols = reactive({
    # req( input$split )
    print( "group_by_cols()")
    group_by_cols =  c( period() , 'orgUnit', 'Facilities',
                        'dataSet' ) 
    
    group_by_cols = c( group_by_cols, levelNames() )
  
    
    if ( input$split != 'None' ) group_by_cols = c( group_by_cols , input$split )
    
    # if ( length( selectedOUs() > 0 ) ) 
      # group_by_cols = c( group_by_cols , 'Facilities' )
    
    # # If not merge when total, show separate datsets
    # if ( !input$merge & input$total ) group_by_cols = c( group_by_cols , 'dataSet' )
    #   
    print( "end group_by_cols()") ; #print( group_by_cols )
    return( unique( group_by_cols ) )

})

data.total = reactive({
  req( plotData() )
  req( group_by_cols() )
  req( period() )
  print( 'data.total()')
  
  .period = period()
  # if ( input$merge & input$total ){
    
    .group_by_cols = unique( c( group_by_cols() ) )
    # print( '.group_by_cols:' ) ; print( .group_by_cols )

    # Total categories by facilities and datasets
    data = plotData() 
    # %>% 
    #   group_by(  !!! dataset_group_by_cols  ) 

    data = setDT(data)[ , .( total = sum( dataCol , na.rm = TRUE  ) ) ,
                           by = .group_by_cols ] %>% 
      as_tibble()
    
    # Merge  datasets 
    # Set all dataSets to Combined and re-summaries taking mean
    # print( 'data.total datasets' );  print( dataSets() )
    # print( 'input$merge ') ; print( input$merge )
    # print( 'data datsets ' ) ;  print( unique(data$dataSet) %>%                                        str_replace_all(fixed("\r"), ""))
    
    merge = length( input$merge ) > 1 
    if ( merge ){
      print( 'merging datasets' )

      # MErge datasets
      dataMerge = data %>%
        mutate( dataSet = dataSet %>% str_replace_all(fixed("\r"), "") ) %>%
        filter( dataSet %in% input$merge ) %>%
        mutate( dataSet = 'Combined' ) 
 
      # data.table sum
      print( 'merge data.table sum') ; 
      dataMerge = setDT( dataMerge )[ , .(total = mean( total , 
                                             na.rm = TRUE  )) ,
                           by = .group_by_cols ] %>% 
        as_tibble()
      
      print( 'dataMerge done' );  # glimpse( dataMerge )
      
      dataNotMerge = data %>%
        mutate( dataSet = dataSet %>% 
                  str_replace_all(fixed("\r"), "") ) %>%
        filter( ! dataSet %in% input$merge ) 
      
      print( 'dataNotMerge' );  glimpse( dataNotMerge )
      
      if ( nrow( dataNotMerge ) > 0 & input$dataset ){
        
       data = bind_rows( dataMerge ,
                         dataNotMerge %>%
                           mutate( dataSet = 'Combined' )
                         )  

       data = setDT( data )[ , .(total = sum( total , na.rm = TRUE  ) ) ,
                    by = .group_by_cols ] %>%
         as_tibble()

       } else  {
        data  = bind_rows( dataMerge , dataNotMerge )
        print( 'data.total duplicates' )  
        # saveRDS( data, 'data.rds' )
        # print( data %>% duplicates %>% glimpse )
          } 
    }

  
  print( 'data.total key_cols:')
  
  key.cols = setdiff( group_by_cols() , .period ) 
      
  # print( key.cols )
  
  data.total = 
      data %>% 
      as_tsibble( index = !! rlang::sym( .period )  , 
                  key =  all_of(  {{key.cols}} ) ) %>%
      # fill_gaps( .full = TRUE  ) %>%
      mutate( 
              total = replace_na( total , 0) 
              )  # for plotting, replace missing with zero 
  
  print( 'data.total finalized' ); # print( toc())
  return( data.total )
    

})

num_facilities = reactive({
  req( data.total() )
  print('num_facilities()')
  .d = data.total()
  l = length( unique( .d$Facilities ) )
  print( paste( 'number of Facilities', l ) )
  return( l )
})

num_datasets = reactive({
  req( data.total() )
  print('num_datasets()')
  .d = data.total()
  l = length( unique( .d$dataSet ) )
  print( paste( 'number of dataSets', l ) )
  return( l )
})

hts = reactive({   
  print( "hts():" )
  adms = backtick( levelNames() )
  
  if (input$hts){ 
    hts = paste( adms, collapse = "/" ) 
  } else {
    hts = paste( adms[1:3], collapse = "/" ) 
  }
  
  hts = paste( "(" , hts , ")" )
  
  # if >1 Facilities (ie. selected)
  if ( num_facilities() > 1 )  hts = paste( 
           'Facilities *' , hts 
           )
  
  # if >1 dataset 
  if ( num_datasets() > 1 )  hts = paste( 
           'dataSet *' , hts
           )
  
  # # Cross by split
  if ( !input$split %in% 'None' ) hts =
    paste( input$split , '*' ,  hts )
  # 
  # Cross by selected and split
  # if ( length( selectedOUs() ) > 0  & !input$split %in% 'None' ) hts =
  #   paste( input$split ,  ' * Facilities * (', hts , ')' )
  
  print( "end hts():" ); print( hts )
  return( hts )
})

data.hts = reactive({
  req( data.total() )

  print( 'data.hts():' );   tic()

  .d = data.total()

  .d = .d %>%
    aggregate_key(  .spec = !!rlang::parse_expr( hts() ) ,
                    total = sum( total , na.rm = T )
                    ) 
  
  print( 'end data.hts():' ) ; toc()
    return(.d)
})

aggregatePlotData = reactive({
   req( data.hts() )
   print( 'aggregatePlotData()' )
  
  .d = data.hts() %>% 
      filter( 
        ! is.na( !! rlang::sym( levelNames()[1] ) )
        , is_aggregated( !! rlang::sym( levelNames()[1] ) )
      ) %>%
       mutate( 
         grouping_var = 'Total' )
     
     if ( num_datasets() > 1 ){
       print( 'num_datasets()>1:') ;
       .d = .d %>% 
       filter( !is_aggregated( dataSet ) ) %>%
       mutate( dataSet = as.character( dataSet ) %>%
           str_remove_all( "<aggregated>" ) ,
           grouping_var = dataSet )
       print( unique(.d$dataSet))
     }  
     
     if ( num_facilities() > 1 ){
       print( 'num_facilities()>1:') ; 
       .d = .d %>% 
       filter( !is_aggregated( Facilities )  ) %>%
       mutate( Facilities = as.character( Facilities ) %>%
           str_remove_all( "<aggregated>" )  )
       
       print( unique(.d$Facilities))
     }  
        
    # if split, remove aggregate grouping
     if ( !input$split %in% 'None' ){
       print( '!input split none') ; print( input$split )
       .d = .d %>%
         filter( !is_aggregated( !! rlang::sym( input$split ) ) 
         ) %>%
         mutate( grouping_var = as.character( 
           !! rlang::sym( input$split ) )
         )
       print( unique(.d$grouping_var) )
       # print( glimpse( .d ))
       
     } 
     
     print( 'end aggregatePlotData()' )
     return( .d )
 
})

 caption.text =  reactive({
    paste( 
      ifelse( selectedOUs() > 0 , 
           paste( comma( length( selectedOUs() ) ), 'facilities' ) ,
           "" ) ,
    ifelse( nchar( input$Admn2 ) > 0, paste( input$Admn2 , collapse = "+" ) ) ,
    ifelse( nchar( input$Admn3 ) > 0, paste(  "/" , input$Admn3 , collapse = "+" ) ) ,
    ifelse( nchar( input$Admn4 ) > 0, paste(  "/" , input$Admn4, collapse = "+"   ) )
                         )
  })

plotAgregateValue = reactive({
  
  req( aggregatePlotData() )
  req( input$split )
  print( 'plotAgregateValue():' )

  .d = aggregatePlotData()
  
  data.text = paste( unique( plotData()$data ),
                     collapse = " + " ) 
  
  # print( 'data.text'); print( data.text )
  
  .limits = c(0, NA)
  
     
  print('plotting aggregate data');
  

  g = .d %>% 
    fill_gaps( .full = TRUE  ) %>%
    # autoplot( vars( total , grouping_var ) )
    ggplot( aes(x = !! rlang::sym( period() ) , y = total
             , group = grouping_var  
             , colour =  grouping_var
            ) )  +
      geom_line()
  
  # Line color for mulitple datasets
  if ( num_datasets() > 1 ){
    print( 'unique dataSets'); print( unique( .d$dataSet ) )
    dataSet_breaks = unique( .d$dataSet )
    datSet_labels =  unique( .d$dataSet )
    datSet_labels[ datSet_labels == "" ] = "Combined"
    
    g = g +
    scale_color_discrete( breaks = dataSet_breaks ,
                          labels =  datSet_labels ,
                          drop = TRUE ) +
    guides(color=guide_legend(title="dataSet"))
    
  } else {
     g = g + guides( color = "none" )
  }
  
  # Split data
  if ( !input$split %in% 'None' ){
    g = g + guides(color=guide_legend(title= input$split ))
  }

  
  # facet when selected > 0
  if ( length( selectedOUs() ) > 0 ) g =
  g + facet_wrap( vars( Facilities ) ,
                  scales = 'free' , ncol = 3 ) 
  
  # Time scales
  if ( period() %in% 'Month' )  g = g + 
    scale_x_yearmonth( date_breaks = "1 year" )
  if ( period() %in% 'Week' )  g = g + 
    scale_x_yearweek( date_breaks = "1 year" )
  
  g = g +
    scale_y_continuous( label=comma, limits = .limits ) +
    labs( y = "" , x="" ,
          title = str_wrap( input$indicator , 200 ) ,
          subtitle = str_wrap( data.text , 200 ) 
          , caption =  str_wrap( caption.text() , 200 )
          ) +
    theme_minimal()  
    
  print( ' end plotAgregateValue()' )

  return( g )
})

output$plot_values <- renderPlot({  plotAgregateValue()  })

```




Map 
====================================

Row 
-------------------------------------
  
### Map {.no-padding }

```{r ous }


ous.file = reactive({
  req( data.folder() )
  
  dir = data.folder() 
  
  if ( file.exists( paste0( data.folder() , 'newOUS.rds')  ) ){
     
    f = paste0( dir,'newOUS.rds'  )
    
    } else {
    
    dir.files = list.files( dir )
    ous.files = dir.files[ grepl( 'geoFeatures' , dir.files,
                                              fixed = TRUE  )]
    print( "ous.files:" ) ; print( ous.files )
    f = paste0( dir, most_recent_file( ous.files ) )
    }
  
    print( 'ous file:' ) ; print( f )
    
    if ( !any(file.exists( f ) )) return( NULL )
    
    return( f )
})

ous = reactive({  print( 'reading ous file' ) ; 
  req( ous.file() )
  if ( !any(file.exists( ous.file() ) )) return( NULL )
  showNotification("reading geo features file")
  tic()
  o = readRDS( ous.file() )  
  print( 'finished reading ous file' ) ; toc() 
  print( ' OUS: ' ) ; # print( glimpse( o ))
  return( o )
  })

levelNames = reactive({ 
  l = count( ous() %>% as_tibble, level, levelName ) %>% 
    arrange( level ) %>% pull(levelName ) 
  l = l[ !is.na(l) ]
  return(l)
})

levels = reactive({ 
  levels = 
    count( ous() %>% as_tibble, level, levelName ) %>% 
    arrange( level ) 
  print( "levels()"); print( levels )
  return( levels )
  
})

observeEvent( levelNames(), 
              updateSelectInput( session, 'level' , 
                                 choices = c('leaf',
                                             levelNames() ) , 
                                 selected = 'leaf' )
              )





```

```{r eval = FALSE }

  verbatimTextOutput("selected_rows")

  # Print the rows of the data frame which match the x value
  output$selected_rows <- renderPrint({
    if ( is.null( selectedOUs() ) ) return()
    else {
      head( orgunit.reports() %>% 
              filter( orgUnit %in% selectedOUs() ), 10) #
    }
  })
```

```{r map1 , eval = TRUE }

checkboxInput( "show_map", label ='Display map (may take a minute...)', 
               value = FALSE ) 

plotOutput( 'map' , 
    click = "map1_click" ,
    dblclick = "map1_dblclick" ,
    hover = "map1_hover" ,
    brush = "map1_brush" )


hf = reactive({ ous() %>% filter( feature %in% "POINT"  ) })
admins = reactive({ ous() %>% filter( feature %in% c('MULTIPOLYGON', 'POLYGON') ) })
fs_selected = reactive({ ous() %>% filter( orgUnit %in% selectedOUs() ) })

# split_geofeatures = reactive({ split( ous() ,  ous$levelName ) })
# levels = names( split_geofeatures )
# not_all_empty_geo = map_lgl( split_geofeatures ,
#                                  ~!all(is.na(st_dimension(.x))) )
map1 = reactive({ 
  
  req( admins())
  req( hf())
  
  if ( input$show_map ){
    ggplot( ) + 
    geom_sf( data = isolate( admins() ) ) +
    geom_sf( data = isolate( hf() ) , alpha = .25 ) +
    geom_sf( data = fs_selected() , color = 'brown' ) +
    theme_ipsum()
  } else { NULL }
  
})

output$map<-renderCachedPlot({ map1() } ,
                              cacheKeyExpr = { list( input$country , 
                                                     input$show_map , 
                                                     fs_selected() )
                                } ) 

```

```{r leaflet , eval = FALSE }
library( leaflet )
leafletOutput( 'map1' )

map1 = reactive({ 
    split_geofeatures = split( ous() ,  ous()$levelName )
    
    levels = names( split_geofeatures )
    
    # fs = ous  
    
    # mapview( fs )
    
    # # test for empty geometry
    not_all_empty_geo = map_lgl( split_geofeatures ,
                                 ~!all(is.na(st_dimension(.x))) )
    # 
    # # print( paste( 'not_all_empty_geo: ', not_all_empty_geo ) )
    # 
    # print( levels )
    # 
    n_levels = sum( not_all_empty_geo )
    # 
    colors = RColorBrewer::brewer.pal(n_levels, 'Pastel1')
    names( colors ) = levels[ not_all_empty_geo ]
    # colors = topo.colors(10)[ n_levels ] 
    # 
    # 
    m_list = map( levels[ not_all_empty_geo ] ,
                  ~ mapView( split_geofeatures[ .x ] ,
                            col.regions = colors[ .x ]
                  ) )

    m = reduce( m_list , `+`)

    m@map
})

output$map1<-renderLeaflet({ map1() } ) 
```

```{r map_brush, eval=FALSE }
verbatimTextOutput("Map.info")

output$Map.info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             " ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }

    paste0(
      "click: ", xy_str( input$map1_click ),
      "dblclick: ", xy_str(input$map1_dblclick),
      "hover: ", xy_str(input$map1_hover),
      "brush: ", xy_range_str(input$map1_brush)
    )
  })
```


Quality
====================================

Row
-------------------------------------


```{r print_mad, include = FALSE , eval=FALSE }

htmlOutput("mad_value")

 # Print the MAD value
  output$mad_value <- renderText({
    
    req( input$mad )
    

      HTML("You've selected a MAD cutoff <code>", 
           input$mad, 
           "for extreme values", 
           "</code>")

  })


```


### Extreme Outliers 

```{r dTs.extreme, eval=FALSE }



pb = NULL
# .total = reactive({ length( key_size( dTs() ) ) })
# pb <- progress_bar$new( 
#     format = ":current :percent  [:bar] :elapsedfull",
#     total = .total() , clear = FALSE, width= 50 )

mad = reactive({ input$mad })

dTs.extreme = reactive({ 
  
  print( 'dTs.extreme ... ' )
  print( paste( 'MAD is ', mad() ) )
  
  dtse = 
    d() %>%
    filter( orgUnit %in% selectedOUs() ) %>%
    as_tsibble( index = period, key = orgUnit ) %>% 
    pivot_wider( id_cols = c( orgUnit , period ) , 
                 names_from = "vars", 
                 values_from = "dataCol" ) %>%
    group_by( orgUnit ) %>% 
    mutate( across( all_of( dataCols$x ) , 

                                ~clean_ts( . ,
                      interpolate = FALSE ,
                      .clean = "MAD" ,
                      MAD = as.numeric( mad() ) # median absolute deviation > 5
                      , .pb = pb
                      )  
                    # , otherwise = NA )
    ) 
           
    ) 
  
  # %>% 
  # 
  #   pivot_longer( {{ dataCols$x }} ,
  #                 names_to =  'vars' ,
  #                 values_to = 'cleanEO' )
  
  # glimpse( dtse )
  print( 'dTs.extreme ... finished' )
  return( dtse )
})

```


```{r dTs.extreme.total , eval=FALSE}

dTs.extreme.total = reactive({
  
  
  dTs.extreme() %>% 
    ungroup() %>%
    summarise( across( all_of(  dataCols$x ) , sum, na.rm = TRUE ) )
  
})

```


```{r plot_mad, eval=FALSE}

plotOutput( 'plot_mad' , 
    click = "plot_mad_click" ,
    dblclick = "plot_mad_dblclick" ,
    hover = "plot_mad_hover" ,
    brush = "plot_mad_brush" )

plot_mad = reactive({
  
  if ( !is.character( dataCols$x ) ) return()
  
  g = ggplot( dTs.extreme.total() %>% 
                pivot_longer( dataCols$x  ,
                  names_to =  'vars' ,
                  values_to = 'cleanEO' ) ,
              aes( x = period , y = cleanEO ) ) +
    facet_wrap( ~ vars , scales = 'free' ) +
    geom_line()

  return(g)
})

output$plot_mad <- renderPlot({  plot_mad()  })
```

Row
-------------------------------------

### STL Outliers 

```{r dTs.stl , eval=FALSE}


pb = NULL
# pb <- progress_bar$new( 
#     format = ":current :percent  [:bar] :elapsedfull",
#     total = .total() , clear = FALSE, width= 50 )

mad = reactive({ input$mad })

dTs.stl = reactive({ 
  
  print( 'dTs.stl ... ' )

  dtsstl =  
    dTs.extreme() %>% 
    filter( orgUnit %in% unique( dTs.extreme()$orgUnit )[] ) %>%
    group_by( orgUnit ) %>% 
    mutate( across( all_of( dataCols$x ) , 

            ~clean_ts( . ,
                      interpolate = FALSE ,
                      .clean = 'tsclean' ,
                      MAD = as.numeric( mad() ) # median absolute deviation > 5
                      , .pb = pb
                      )  
                    # , otherwise = NA )
    ) 
    )
  
  # glimpse( dtsstl )
  print( 'dTs.stl ... finished' )
  return( dtsstl )
})

```


```{r dTs.stl.total , eval=FALSE}

dTs.stl.total = reactive({
  
  
  dTs.stl() %>% 
    ungroup() %>%
    summarise( across( all_of(  dataCols$x ) , sum, na.rm = TRUE ) )
  
})

```


```{r plot_dTs.stl , eval=FALSE}

plotOutput( 'plot_dTs.stl' , 
    click = "plot_dTs.stl_click" ,
    dblclick = "plot_dTs.stl_dblclick" ,
    hover = "plot_dTs.stl_hover" ,
    brush = "plot_dTs.stl_brush" )

plot_dTs.stl = reactive({
  
  if ( !is.character( dataCols$x ) ) return()
  
  g = ggplot( dTs.stl.total() %>% 
                pivot_longer( dataCols$x  ,
                  names_to =  'vars' ,
                  values_to = 'cleanEO' ) ,
              aes( x = period , y = cleanEO ) ) +
    facet_wrap( ~ vars , scales = 'free' ) +
    geom_line()

  return(g)
})

output$plot_dTs.stl <- renderPlot({  plot_dTs.stl()  })
```


Trend / Evaluation 
====================================

Row 
-------------------------------------

### Intervention Date

```{r}

# selectInput("filter_data", label = "Filter data:" , 
#               choices = NULL , 
#               selected = NULL  ) 

dates = reactive({ 
    req( dataset() )
    print('dates():'); 
    .period = period()
    dates = dataset() %>% pull( !! rlang::sym( .period )) %>% 
      unique 
    
    # print( dates )
    print( max( dates ))
    print( 'end dates()')
    return( dates )
    
    })


selectInput("evaluation_month", label = "Starting evaluation:" , 
              choices = NULL , 
              selected = NULL ) 

selectInput("horizon", label = "Number periods after intervention:" , 
              choices = c(3,6,12,18,24,36) , 
              selected = 12 ) 


checkboxInput( "selected" , label ='Show selected facilities',
               value = TRUE  ) 


checkboxInput( "legend" , label ='Show legend',
               value = FALSE  ) 

checkboxInput( "plotly" , label ='Plotly Chart',
               value = FALSE  ) 

```

### Forecast Type

```{r}

# selectInput("filter_display", label = "Filter display:" , 
#               choices = NULL , 
#               selected = NULL  ) 


checkboxInput( "smooth" , label ='Show smoothed trend line (loess)',
               value = FALSE  ) 

checkboxInput( "pre_evaluation" , label ='Predicted values during year prior to intervention (to gauge accuracy of time-series model)',
               value = FALSE  ) 


checkboxInput( "evaluation" , label ='Predicted values during evaluation period (assuming no intervetion)',
               value = FALSE  ) 

checkboxInput( "scale" , label ='Scale values (x/mean - 1)',
               value = FALSE  ) 


```


### Model Details

```{r}


selectInput("model", label = "Time-series model:" , 
              choices = c('ETS' , 'ARIMA', 'Prophet') , 
              selected = 'ETS'  ) 


checkboxInput( "forecast_ci" , label ='Confidence interval',
               value = FALSE  ) 

checkboxInput( "bootstrap" , label ='Bootstrap prediction',
               value = FALSE  ) 

selectInput("Reps", label = "Iterations" , 
              choices = c(100, 1000, 5000, 10000) , 
              selected = 1000  ) 

# textInput( 'model_text' , label = 'Model' , value = NULL )

checkboxInput('reconcile', label = 'Reconcile models' ,
            value = FALSE )


```

### Administrative Hierarchy

```{r}


selectInput("agg_level", label = "Aggregate to" , 
              choices = NULL , 
              selected = 1  ) 


checkboxInput( "facet_admin" , label ="Facet by admin",
               value = FALSE  )


```

```{r adm_hierarchies}



observe({  updateSelectInput( session, 'agg_level' , 
                              choices = levelNames() , 
                              selected = levelNames()[1] ) # 12 months before latest date
  } )


observe({  updateSelectInput( session, 'Admn2' ,
                              choices = unique( 
                                dataset()[, levelNames()[2] ] ) ,
                              selected = NULL 
                              ) 
  } )

observe({  updateSelectInput( session, 'Admn3' ,
                              choices = 
                                dataset() %>% 
                                  filter(
                                  !! rlang::sym( levelNames()[2] ) %in% input$Admn2 ) %>% 
                                  pull( !! rlang::sym( levelNames()[3]  ) ) %>% 
                                          unique ,
                              selected = NULL 
                              ) 
  } )

observe({  updateSelectInput( session, 'Admn4' ,
                              choices = 
                                dataset() %>% 
                                  filter(
                                  !! rlang::sym( levelNames()[3] ) %in% input$Admn3 ) %>% 
                                  pull( !! rlang::sym( levelNames()[4]  ) ) %>% 
                                          unique ,
                              selected = NULL 
                              ) 
  } )


admin_names = function( level = NULL ){
  admin_names = ous() %>% 
    as_tibble %>%
    filter( levelName %in% level ) %>%
    distinct( name , orgUnit ) %>%
    arrange( name )
  print( 'sub_admins'); print( admin_names )
  return( admin_names )
}


```


Row 
-------------------------------------


### Impact (plot_trends)

```{r forecast_plot}

# conditionalPanel( "input.plotly == true" ,
                  # plotlyOutput( "plotly_trends" ) 
# )

# conditionalPanel( "input.plotly == false" , 
                 plotOutput( "plot_trends" ,
                             hover = "plot_hover"  )
                 # ) 
selectInput( "var_y", "Y-Axis", choices = NULL )
uiOutput( "dynamic" )

observe({  
  updateSelectInput( session, 'var_y' ,
          choices =  names( trendData() ) 
          )
  } )

observeEvent(  dates() , {  
  updateSelectInput( session, 'evaluation_month' ,
          choices =  dates()  , 
          selected = dates()[ round(length(dates())/2) ]
            # ifelse( period() %in% 'Month' , 
            #                  dates()[12], 
            #                  dates()[52] )
                             # length(  dates()  ) - 12  ,
                             # length(  dates()  ) - 12            )
                             )
  } )
            

observeEvent(
  input$split  , 
  
  { 
  if ( !input$split %in% 'None' ){
    
    print( "input$split:" ); print( input$split )
    # print( "data.total():" ); # glimpse( data.total() )
    
    # splits = data.total() %>% pull( .data[[ input$split ]] ) %>% unique
    
    splits = data.total()[, input$split] %>% unique
    
    print( paste( 'splits: ', splits  ) )

    updateSelectInput( session, 'filter_data' , choices =  c( 'All', splits ) )
    
    updateSelectInput( session, 'filter_display' , choices =  c( 'All', splits ) )
  
  } else {
    
    updateSelectInput( session, 'filter_data' , choices =  c( 'All' ) )
    updateSelectInput( session, 'filter_display' , choices =  c( 'All' ) )
  }
} )

backtick <- function(x) paste0("`", x, "`")

sub_agg_level = reactive({
  levels() %>%
     mutate( parent = dplyr::lag( levelName ) ) %>%
     filter( parent == input$agg_level ) %>%
     pull( levelName )
})
  
trendData = reactive({
  req( data.hts() )
  # req( aggregatePlotData() )
  print( 'trend data() ' )
  
  .d = data.hts()
  
  if (input$selected & !is.null( selectedOUs() ) ){
    .d = .d %>% filter( Facilities == 'Selected' )
  } 
    
  print( "input$agg_level:" ); print( input$agg_level )


  print( "sub_agg_level:" ); print( sub_agg_level() )
   
  # .d = data.hts() %>% 
  #     filter( 
  #       ! is.na( !! rlang::sym( levelNames()[1] ) )
  #       , is_aggregated( !! rlang::sym( levelNames()[1] ) )
  #     ) 
  
  sub_agg = sub_agg_level() 
  print( 'sub agg level filter' ) ; print( sub_agg )
  
  .d = .d %>% 
      filter( 
        ! is.na( !! rlang::sym( input$agg_level   ) ) 
        # next line is good for level 0
        , ! is_aggregated(  !! rlang::sym( input$agg_level   ) )
      )
  
  print( '!is_empty(sub_agg)' ); 
  print( sub_agg )
  print(!is_empty(sub_agg)); 
  print( class( sub_agg ));
  if ( !is_empty(sub_agg) ){
    print( 'filtering by sub_agg' )
    .d = .d %>% filter( 
          is_aggregated( !! rlang::sym( sub_agg  ) )
    )
  }
    
    .d = .d %>%
       mutate( 
         grouping_var = 'Total' ) %>%
      fill_gaps( .full = TRUE  )

     
     print( '.d in trendData' ); # glimpse(.d)
     
     if ( num_datasets() > 1 ){
       .d = .d %>%
       filter( !is_aggregated( dataSet ) ) %>%
       mutate( dataSet = as.character( dataSet ) %>%
           str_remove_all( "<aggregated>" ) ,
           grouping_var = dataSet )

     }

     if ( num_facilities() > 1 ){
       .d = .d %>%
       filter( !is_aggregated( Facilities )  ) %>%
       mutate( Facilities = as.character( Facilities ) %>%
           str_remove_all( "<aggregated>" )  )

       print( 'Facilities:') ; print( unique(.d$Facilities))
     }
        
    # if split, remove aggregate grouping
     if ( !input$split %in% 'None' ){
       print( 'input split:') ; print( input$split )
       .d = .d %>%
         filter( !is_aggregated( !! rlang::sym( input$split ) ) 
         ) %>%
         mutate( grouping_var = as.character( 
           !! rlang::sym( input$split ) )
         )
       print( '.d  aggregated split'); 
       print( unique(.d$grouping_var) )
       # print( glimpse( .d ))
       
     } 

  print( 'nrow(.d)'); print(nrow(.d))
     
    # if ( !input$split %in% 'None' & !input$filter_data %in% 'All' ){
    #     print( 'filter_data is not null' )
    #     .d = .d %>% 
    #       filter( .data[[ input$split ]] %in% input$filter_data )
    # }
  
  if ( input$scale ) .d = .d %>% 
      mutate( 
        total = ( total/ mean( .d$total , na.rm = TRUE ) ) -1
    )
  
  print( 'end trend data():'); #print( class( .d ) ); # print(.d)

  
  return( .d )
})

evaluationParameters <- reactiveValues( Month  = NULL )

tsModel = reactive({
  req( trendData() )
  req( input$evaluation_month )
  
  if ( !input$evaluation ) return( NULL )
  print( 'tsModel' )
  
  # Filter data to period just before evaluation start
  print( input$evaluation_month )
  eval_month = input$evaluation_month
  time_period = yearmonth( eval_month  ) # - month(1)
  
  fit.data  = trendData() %>%
    filter_index( ~ as.character( time_period ) ,
                  .preserve = TRUE )
  
  if (input$model %in% 'ARIMA' ){
    fit = fit.data %>% model( a = ARIMA( total ) ) 
    
  if ( input$reconcile ) fit = fit %>% 
        reconcile( 
          mint = min_trace(a, method = "mint_shrink") 
          )
    
    return( fit )
  } 
  
  if (input$model %in% 'ETS' ){
    fit = fit.data %>% model( a = ETS( total )  ) 
    
    print('ETS model') ; #print( fit )
    
  if ( input$reconcile ) fit = fit %>% 
        reconcile( 
          mint = min_trace(a, method = "mint_shrink") 
          )
    
    return( fit )
  } 
  
  if (input$model %in% 'Prophet' ){
    fit =  fit.data %>% model( 
            prophet = prophet( total ~

                                    growth( type = 'logistic',
                                            changepoint_range = 1 ,
                                            changepoint_prior_scale = 1 ,
                                            capacity = 1e5 ,
                                            floor = 0 ) +
                                    season(period=12, 
                                           order = 4 ,
                                           type='multiplicative'),
                               seed = TRUE)
        )
   
    print( 'model fit' )
    return( fit )
  } 
  
})

tsPreModel = reactive({
  req( trendData() )
  req( input$evaluation_month )
  
  if ( !input$pre_evaluation ) return( NULL )

  eval_month = input$evaluation_month 
  time_period = yearmonth( eval_month  ) - 12
  
  fit.data  = trendData() %>%
    filter_index( ~ as.character( time_period ) )
  

   if (input$model %in% 'ARIMA' ){
    fit = fit.data %>% model( 
      arima = ARIMA( fabletools::box_cox( total , lambda = .5  ) ~
                                    pdq( 0:2, 0:1, 0:2 ) +
                       PDQ( 0:2, 0:1, 0:2 ,  period = 12 )  )
      )
   } 
  
  if (input$model %in% 'ETS' ){
    fit = fit.data %>% model( a = ETS( total )  ) 
    
  if ( input$reconcile  ) fit = fit %>% 
        reconcile( 
          mint = min_trace(base, method = "mint_shrink") 
          )
    
    return( fit )
  } 
  
  if (input$model %in% 'Prophet' ){
    fit =  fit.data %>% model( 
            prophet = prophet( total ~

                                    growth( type = 'logistic',
                                            changepoint_range = 1 ,
                                            changepoint_prior_scale = 1 ,
                                            capacity = 1e5 ,
                                            floor = 0 ) +
                                    season(period=12, 
                                           order = 4 ,
                                           type='multiplicative'),
                               seed = TRUE)
        )
  }

  print( 'pre fit' ); # glimpse( fit )
  return( fit )
  
})

tsForecast = reactive({ 
  
  req( tsModel() ) 
  req( input$horizon )
  print( 'tsForecast()' )
  
  if ( input$bootstrap ){
    
    fcast = tsModel() %>% 
      forecast( h = as.numeric( input$horizon ) ,
                bootstrap = TRUE, 
                times = as.integer( input$Reps ) 
      )
  } else {
    fcast = tsModel() %>%
      forecast( h = as.numeric( input$horizon ) ) 
  }
  
  fcast = fcast %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
  print( 'fcast:' );  #glimpse( fcast )
  return( fcast )
  })

tsPreForecast = reactive({ 
  
  req( tsPreModel() ) 
  req( input$horizon )
  
  fcast = tsPreModel() %>% forecast( h = 12 )
  
  fcast = fcast %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
    
  # print( 'pre-fcast' ) ; print( fcast )
  return( fcast )
  })

MAPE = reactive({
  req( tsPreForecast() ) 
  print('MAPE')
  predicted = tsPreForecast() %>% as_tibble() %>% select(-total)
  actual =  trendData() 
  d = predicted %>%
     inner_join( actual , by = period() ) 
 
  e = d %>% as_tibble() %>%
        # group_by( orgUnit , data  )  %>%
        summarise( 
          mape = ifelse( mean( total , na.rm = T ) > 0 ,
                       mean( abs( total - .mean ) , na.rm = T ) / 
                       mean( total , na.rm = T ) ,
                       NA ) 
                   ) 
  print( "MAPE"); print( e$mape)
  return( scales::percent( e$mape )  )
  
})

key.mape = reactive({
  req( tsPreForecast() ) 
  req( trendData() ) 
  
  print('key.mape')
  
  predicted = tsPreForecast() %>% 
    rename( pred = .mean ) 
  
  actual =  trendData() %>% 
    rename( actual = total )
  
  keyvars = key_vars( actual )
  print('keyvars'); print( keyvars )
  
  truth = predicted %>% 
     inner_join( actual , by = c( period() , keyvars  ) )  
  
  print( 'truth'); #print( truth )
  
  mid_point = round( as.integer( input$horizon ) /2  )
  
  e = truth %>%
    group_by_key() %>%
    index_by( 1 ) %>%
    summarise( 
          mape = ifelse( mean( pred , na.rm = T ) > 0 ,
                       mean( abs( actual - pred ) , 
                             na.rm = T ) / 
                       mean( pred , na.rm = T ) ,
                       NA ) ,
          !! rlang::sym( period() )  := nth( !! rlang::sym( period() )  , mid_point ) ,
          actual = ifelse( mape>=0 , max( actual, na.rm = TRUE ),
                           min( actual, na.rm = TRUE  ) 
                           #nth( actual , mid_point ) 
          ) ,
          just = ifelse( mape >= 0 , 2, -2 )
          ) %>%
  as_tibble() %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
  print( "end key.mape"); glimpse(e )
  return( e )
})

MPE = reactive({
  req( tsForecast() ) 

  print('MPE')
  
  predicted = tsForecast() %>% as_tibble() %>% select(-total)
  actual =  trendData() 
  
  d = predicted %>%
     inner_join( actual , by = period() ) 
 
  e = d %>% as_tibble() %>%
        # group_by( orgUnit , data  )  %>%
        summarise( 
          mpe = ifelse( mean( .mean , na.rm = T ) > 0 ,
                       mean(  total - .mean  , na.rm = T ) / 
                       mean( .mean , na.rm = T ) ,
                       NA ) 
                   ) 
  
  print( "MPE"); print( e$mpe)
  return( scales::percent( e$mpe )  )
  
})

key.mpe = reactive({
  req( tsForecast() ) 
  req( trendData() ) 
  
  print('key.mpe')
  
  predicted = tsForecast() %>% 
    rename( pred = .mean ) 
  
  actual =  trendData() %>% 
    rename( actual = total )
  
  keyvars = key_vars( actual )
  print('keyvars'); print( keyvars )
  
  truth = predicted %>% 
     inner_join( actual , by = c( period(), keyvars  ) )  
  
  print( 'truth'); #print( truth )
  
  mid_point = round( as.integer( input$horizon ) /2  )
  
  e = truth %>%
    group_by_key() %>%
    index_by( 1 ) %>%
    summarise( 
          mpe = ifelse( mean( pred , na.rm = T ) > 0 ,
                       mean( actual - pred  , na.rm = T ) / 
                       mean( pred , na.rm = T ) ,
                       NA ) ,
          !! period()   := nth( !! rlang::sym( period() )  , mid_point ) , 
           actual = ifelse( mpe>=0 , max( actual, na.rm = TRUE ),
                           min( actual, na.rm = TRUE  ) 
                           #nth( actual , mid_point ) 
          ) ,
          just = ifelse( mpe >= 0 , 1, -1 )
          ) %>%
  as_tibble()  %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
  print( "mpe"); #glimpse(e )
  return( e )
})

ci_levels = reactive({
  if ( ! input$forecast_ci ) return( NULL )
  return( 90 )
})

plotTrends = reactive({
  
  req( trendData() )
  req( input$split )
  # req( input$evaluation_month )
  print( 'plotTrends():' )

  .limits = if ( input$scale ){
    c( NA , NA ) } else { 
      c( 0 , NA ) }
 
  data.text = paste( unique( plotData()$data ), collapse = " + " )
  
  .d = trendData() 
  print( 'ploTrends .d:'); #glimpse(.d)
  
  # if ( !input$filter_display %in% 'All' ) .d = .d %>% 
  #         filter( .data[[ input$split ]] %in%
  #                   input$filter_display )

   
  g = .d %>%
  autoplot( total ) +
    # ggplot( aes(x = Month, y = total
    #          , group = grouping_var
    #          , color =  grouping_var
    #         ) )  +
    # geom_line() +
  theme_minimal() 
  
  print( 'basic plot done' )
  
  if ( !input$legend ) g = g + 
    theme(legend.position = "none")
  
  if ( !input$split %in% 'None' ){ 
    g = g + geom_label_repel( 
               aes( label = grouping_var , group = grouping_var )
               )
  }
  
  # Determine number of agg levels available
  # If only one, do not facet (causes error, perhaps because of autoplot?)
  
  num_agg_levels = count( .d %>% as_tibble , 
                          !! rlang::sym( input$agg_level ) ) %>%
    nrow()

  # if ( input$agg_level != levelNames()[1] & input$facet_admin ){
  if ( num_agg_levels  > 1 & input$facet_admin ){
    print( 'facets' )
    g = g +
    facet_wrap( vars(!! rlang::sym( input$agg_level ) ) ,
                   scales = "free_y" )
  }
  
  g = g +

    scale_x_yearmonth("", date_breaks="1 year" ) +
    scale_y_continuous( label=comma, limits = .limits ) +
    scale_color_discrete( drop = TRUE  ) +
    labs( y = "" , x="" ,
          title = str_wrap( input$indicator , 200 ) ,
          subtitle = str_wrap( data.text , 200 ) 
          , caption =  str_wrap( caption.text() , 200 )
          ) 
  print( 'axis scales and labs done' )
  
  #### Evaluation Trend Line
  if ( input$evaluation ){
    print( 'evaluation line ' )
    eval_date =   yearmonth( input$evaluation_month  ) 
    
   g = g + 
    autolayer( tsForecast()
               , level = ci_levels()
               , color = 'black'
               , linetype = 'dashed', size = 1
               ,  alpha = .5 ) +
     
    # geom_line( data = tsForecast() %>%
    #   as_tibble %>%
    #   mutate( !! input$agg_level := as.character( !! rlang::sym( input$agg_level  ) ) ) ,
    #            aes( x = Month, y = .mean ) ,
    #            color = 'blue' , alpha = .5 ) 
    geom_vline( xintercept = as.Date( eval_date ) ,
                color = 'black', alpha = 1 ) +
    # annotate( "text" ,
    #           x = as.Date( eval_date ) ,
    #           y = Inf ,
    #           hjust = 0 , vjust = 1 ,
    #           label = paste( "MPE:\n" )
    #           ) +
    geom_label_repel( data =  key.mpe() ,
               aes(  x = !! rlang::sym( period() ) , y = actual , 
               label = paste( "MPE:" , percent( mpe, accuracy = 1.0 ) ) ,
               hjust = just 
               ) ,
               # force_pull = 0 , 
               segment.colour = NA
               )
  }
  
  print( 'evaluation line done' )

  ### Pre-Evaluation trend line
  if ( input$pre_evaluation ){
    
    print( 'pre evaluation line ' )
    pre_eval_date = yearmonth( input$evaluation_month  ) - 12
        # month( as.integer( input$horizon ) )
      
    print( 'pre_eval_date is' ); print( pre_eval_date )
    g = g + 
    autolayer( tsPreForecast()
               , level = ci_levels()
               , color = 'black' 
               , linetype = 'dotted'  , size = 1
               ,  alpha = .5 ) +
    # geom_line( data = tsPreForecast(), aes( y = .mean ) ,   color = 'light blue', alpha = 1 ) +
    geom_vline( xintercept = as.Date( pre_eval_date ) ,
                color = 'brown' ,
                alpha = .25 ) +
    # annotate( "text" ,
    #           x =  as.Date( pre_eval_date ) ,
    #           y = Inf ,
    #           hjust = 0 , vjust = 1 ,
    #           label = paste( "MAPE:"  )
    #           ) +
    geom_label_repel( data =  key.mape() ,
               aes(  x = !! rlang::sym( period() ) , y = actual , 
               label = paste( "MAPE:" , percent( mape, accuracy = 1.0 ) ) ,
               hjust = just ) ,
               # force_pull = 0 , 
               segment.colour = NA 
               )

  }
  
  print( 'pre-evaluation line done' )
   
  if (input$smooth){
    print( 'agg level' ); print( input$agg_level )
    .d. = .d %>% 
      as_tibble %>%
      mutate( !! input$agg_level := as.character( !! rlang::sym( input$agg_level  ) ) )
    
    print( 'smooth .d.') ; #glimpse(.d. )
    g = g + 
    geom_smooth( data = .d. , 
                 alpha = .75 )
  
  } 
  
  # Confidence Interval
  # if ( input$forecast_ci & input$evaluation ){
  #   print( 'confidence intervals line ' )
  #   fbl = tsForecast() 
  #   print( 'glimpse fbl') ; # glimpse( fbl )
  #   ci = fbl %>% 
  #     mutate( hilo = hilo( total , 80 ) )
  #   ci$.lower = ci$hilo$lower 
  #   ci$.upper = ci$hilo$upper 
  #   print( 'glimpse ci') ; # glimpse( ci )
  #   
  #   print( 'summary lower') ; print( summary( ci$.lower ) )
  #   print( 'summary upper') ; print( summary( ci$.upper ) )
  #   
  #   g = g + 
  #     geom_ribbon(  data = ci , 
  #       color = 'blue' , alpha = .5 , 
  #       # fill = 'blue' , 
  #       inherit.aes = FALSE ,
  #       aes( x = Month, ymin = .lower, ymax = .upper )
  #            # ymin = .mean, 
  #            # ymax = .mean 
  #            # )
  #   )
  #   return( g )
  # } 
  #   
  print( 'end plotTrends():' )
  
  return( g )
})


# output$plotly_trends <- renderPlotly({
#   plotly::ggplotly( plotTrends() )  })

output$plot_trends <- renderPlot({ plotTrends()  })

 output$dynamic <- renderUI({
    req(input$plot_hover) 
    verbatimTextOutput("vals")
  })

output$vals <- renderPrint({
    hover <- input$plot_hover 
    # print(str(hover)) # list
    y <- nearPoints( trendData() , input$plot_hover)[input$var_y]
    req(nrow(y) != 0)
    y
  })
 

```

