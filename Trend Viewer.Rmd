---
title: "Trend Viewer"
author: "jp"
date: "1/4/2021"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    theme: 
      version: 4
      bootswatch: sandstone
runtime: shiny
---

```{r setup, include=FALSE}
options(shiny.trace=FALSE)
options(shiny.reactlog=FALSE)

library(shiny)
knitr::opts_chunk$set(echo = FALSE)
source( "data_time_libraries.r")

library(pacman)

pacman::p_load( officer , rvg ,
                tidyverse, scales, plotly ,
                data.table , tidyfast, tidytable ,
        lubridate , anytime, progressr , assertthat  , stringr, 
        readxl, patchwork, cowplot, kableExtra  ,
        tsibble, fable, fabletools, feasts  , 
        fable.prophet ,  fable.bsts  , 
        slider, anomalize, brolgar   ,
        tsbox , CausalImpact , tibbletime , dygraphs  , 
        fpp3  , fabletools  , 
        furrr, tictoc, magrittr, hrbrthemes, data.tree, igraph  ,
        sf, mapview, GGally , plotly , sugrrants, lemon , plotly ,
        shinyscreenshot, ggrepel, shinybusy, DT ,
        HDInterval ,rstanarm , bayestestR , 
        see 
        )

options( dplyr.summarise.inform = FALSE )

## Functions ####
source( "ingest_formula_data.r")
# source( "formula_files.r" )
source( "clean_ts.r" )
source( "outlier.r" )
source( 'Deviation_Expected_Functions.R')
source( 'api_data.r' )
source( 'DToptions.R' )

# most_recent_file = function( file_list_with_date , mark = 3 ){
#   rdsFileSplit = str_split( file_list_with_date, "_")
#   # download_date = map( rdsFileSplit ,
#   #                      ~str_split( .x[ length(.x)] , "\\.")[[1]]
#   # ) %>% map_chr(1) 
#   
#   download_date = map_chr( rdsFileSplit ,
#                        ~.x[which( grepl( fixed("-") , .x ) )] )
#   
#   dates  = map_chr( download_date , ~ anydate(.x)  )
#   
#   if ( identical( dates , character(0) ) ) return( NA )
#   
#   # most recent file 
#   file = file_list_with_date[ which( dates == max(dates, na.rm = T ) ) ]
#   
#   return ( file )
# }


Month_Year = function( x ){ yearmonth( zoo::as.yearmon( x , "%Y%m") ) }

# files = function(  search = 'All' , type = 'xlsx' , other = "" , directory = NULL ){
#                         
#                       dir.files = list.files( directory )
#                       search_and_type =  
#                           str_detect( dir.files, fixed( search , ignore_case=TRUE )  )  &
#                            grepl( paste0( type , '$' ) , dir.files, 
#                                   ignore.case =  TRUE  ) &
#                           grepl( other , dir.files , ignore.case = TRUE ) 
#                       files = dir.files[  search_and_type   ]
#                       return( files[ rev( order( files )) ]  )
#                       }

# file.dir = function( country = NULL ,
#                      dir.base = '../dataDictionary/dhis2_dictionary/Formulas/' ){
#   
#   has.slash.at.end = str_locate_all( dir.base , "/") %>% 
#     unlist %in% nchar( dir.base) %>% any 
#   if ( !has.slash.at.end  ){ dir.base = paste0( dir.base , "/" ) }
#   paste0( dir.base , country , "/" )
# 
# }


# see https://stackoverflow.com/questions/54438495/shift-legend-into-empty-facets-of-a-faceted-plot-in-ggplot2
shift_legend2 <- function(p) {
  # ...
  # to grob
  gp <- ggplotGrob(p)
  facet.panels <- grep("^panel", gp[["layout"]][["name"]])
  empty.facet.panels <- sapply(facet.panels, function(i) "zeroGrob" %in% class(gp[["grobs"]][[i]]))
  empty.facet.panels <- facet.panels[empty.facet.panels]

  # establish name of empty panels
  empty.facet.panels <- gp[["layout"]][empty.facet.panels, ]
  names <- empty.facet.panels$name
  # example of names:
  #[1] "panel-3-2" "panel-3-3"

# now we just need a simple call to reposition the legend
  reposition_legend(p, 'center', panel=names)
}

shift_legend3 <- function(p) {
    pnls <- cowplot::plot_to_gtable(p) %>% gtable::gtable_filter("panel") %>%
      with(setNames(grobs, layout$name)) %>% purrr::keep(~identical(.x,zeroGrob()))

    if( length(pnls) == 0 ) return(p)

    lemon::reposition_legend( p, "center", panel=names(pnls) )
}


```


<!-- CSS defaults: -->
<!-- https://github.com/rstudio/flexdashboard/blob/feature/logo-and-favicon/inst/rmarkdown/templates/flex_dashboard/resources/flexdashboard.css -->

```{css my-css }


.chart-title {
     font-size: 10px;
}

.chart{
    margin: 0px
}

.shiny-input-container{
    margin: 0px
}

.checkbox{
    margin: 0px
}

.selectize-input { 
    font-size: 10pt; 
    font-weight: bold;
    margin: 0 0 0 0;
    white-space: nowrap;
    padding: 5px;
    } 
    
.select-input { 
    font-size: 10pt; 
    font-weight: bold;
    margin: 0 0 0 0;
    white-space: nowrap;
    padding: 5px;
    } 
    
.checkbox-input { 
    margin: 0px
    }

.value-box > .inner {
  padding: 5px;
  padding-left: 5px;
  padding-right: 5px;
}

.value-box .value {
  font-size: 10px;
  font-weight: bold;
  margin: 0 0 0 0;
  white-space: nowrap;
  padding: 0;
}

.value-box .caption {
  font-size: 5px;
}

.section.sidebar {
  position: fixed;
  top: 51px; /* overridden by theme */
  left: 0;
  bottom: 0;
  border-right: 1px solid #e2e2e2;
  background-color: white; /* overridden by theme */
  padding-left: 5px;
  padding-right: 5px;
  visibility: hidden;
}

.section.sidebar form p:first-child {
  margin-top: 5px;
}

.storyboard-nav {
    box-sizing: border-box;
    width: 100% !important; /* This prevents JS transformation on width */
    height: auto; /* This overrides the height */
}

.storyboard-nav .sbnext, .storyboard-nav .sbprev {
    height: auto; /* This overrides the height */
    font-size: 3rem;
}

.storyboard-nav .sbframelist {
    height: auto; /* This overrides the height */
}

.storyboard-nav .sbframelist ul {
    box-sizing: border-box;
    width: 100% !important; /* This prevents JS transformation on width */
    height: auto; /* This overrides the height */
}

.storyboard-nav .sbframelist ul li {
    height: auto; /* This overrides the height */
    width: auto; /* This overrides the width */
}


input[type="number"] {
  max-width: 80%;
}

div.outer {
  position: fixed;
  top: 41px;
  left: 0;
  right: 0;
  bottom: 0;
  overflow-y: auto;
  /*overflow: hidden;*/
  padding: 0;
}

#controls {
  /* Appearance */
  background-color: white;
  padding: 0 10px 10px 10px;
  cursor: move;
  /* Fade out while not hovering */
  opacity: 0.65;
  zoom: 0.9;
  transition: opacity 500ms 1s;
  overflow-y: auto;
}

#controls:hover {
  /* Fade in while hovering */
  opacity: 0.95;
  transition-delay: 0;
}

/* Position and style citation */
#cite {
  position: absolute;
  bottom: 10px;
  left: 10px;
  font-size: 12px;
}

/* If not using map tiles, show a white background */
.leaflet-container {
  background-color: white !important;
}

.tab-content {
  overflow: visible;
}

.selectize-control .selectize-dropdown {
  position: static !important;
}

.select-control .select-dropdown {
  position: static !important;
}

/* Customize fonts */
body, label, input, button, select { 
  font-family: 'Helvetica Neue', Helvetica;
  font-weight: 100;
}

h1, h2, h3, h4 { font-weight: 200; }

#controls:hover {
  /* Fade in while hovering */
  opacity: 0.95;
  transition-delay: 0;
}
```

Inputs {.sidebar data-width=300}
====================================

```{r input, echo=FALSE}

add_busy_spinner(spin = "fading-circle", position = "bottom-right")

inputPanel(
  
  
selectInput("level2", label = "OrgUnit Level2" , 
              choices = NULL, 
              selected = NULL ,
              multiple = TRUE ) ,

selectInput("level3", label = "OrgUnit Level3" ,
              choices = NULL,
              selected = NULL ,
              multiple = TRUE ) ,

selectInput("level4", label = "OrgUnit Level4" ,
              choices = NULL,
              selected = NULL  ,
              multiple = TRUE  ) ,

selectInput("level5", label = "OrgUnit Level5" ,
              choices = NULL,
              selected = NULL  ,
              multiple = TRUE  ) ,

  
  selectInput("source", label = "Original/Cleaned" , 
              choices = c( 'Original', 'Cleaned' ) , 
              selected = 'Original' ) ,
  
  selectInput("split", label = "Split Data By:" , 
              choices = "None" , 
              selected = "None" ) , 
  
  checkboxInput( "count.any", label ='Count any categories', value = FALSE ) ,
  
  checkboxInput( "mostReports", label ='Most frequently reporting facilities', value = TRUE ) ,
  
  selectInput( "startingMonth", label = "begining with", 
               choices = NULL ,
               selected = NULL ) ,
  selectInput( "endingMonth", label = "ending with", 
               choices = NULL , 
               selected = NULL ) ,
  
  actionButton( "screenshot" , "Screenshot" ) ,
  
  selectInput("shotSelection", label = "Screenshot Chart:" , 
              choices = c(NULL, 
                          'plot_reporting_by_month', 
                          'plot_reports_in_a_year', 
                          'map' , 
                          'plot_values' ,
                          'plot_trends'),
              selected = NULL ) 
  # checkboxInput( 'calendar_year', "Calendar Year" , value = TRUE )
)

# testing 
# country = "Burkina Faso"
# indicator = "ANC"
# exclude_recent_month = TRUE


```

```{r screenshot}

observeEvent( input$screenshot , {
  screenshot.file = filename = paste(# input$country,
                                     input$indicator, 
                                     input$shotSelection,
                                     sep="_"  )
  print( paste(
    'Screenshot saved to:' , screenshot.file 
  ))
  
  screenshot( id = input$shotSelection, 
              filename = screenshot.file ,
              scale = 8
  )
})
```


```{r reporting_month_updates}

observeEvent(  dates() , {  
  updateSelectInput( session, 'startingMonth' ,
          choices =  dates()  , 
          selected = min( dates(), na.rm = TRUE )
  )
  } )


observeEvent(  dates() , {  
  updateSelectInput( session, 'endingMonth' ,
          choices =  dates()  , 
          selected = max( dates(), na.rm = TRUE )
  )
  } )



```



Data
===================================

```{r data_inputs}

  


  textInput( "data.directory", label = "Data directory:", 
             value = "../dataDictionary/dhis2_dictionary/Formulas/" ,
             width = '100%'
             # , style = "font-size: 50%;"
             ) 
 
  # selectInput("country", label = "DHIS2 instance (Country) Folder:" , 
  #             choices = NULL 
  # 

  selectInput("indicator", label = "Indicator:" , 
              width = '100%',
              choices = NULL , 
              selected = FALSE,
              multiple = FALSE ,
              selectize = FALSE, 
              size = 4  ##needed for `selected = FALSE` to work ) 
             ) 
  
  
  selectInput("dataset", label = "Data files (from DQA modeling.R) :" , 
              width = '100%',
              choices = NULL , 
              selected = FALSE,
              multiple = FALSE ,
              selectize = FALSE, 
              size = 4  ##needed for `selected = FALSE` to work ) 
             ) 
  
  

  splitLayout( cellWidths = c("25%", "75%"), 
               checkboxInput( "all_categories", 
                              label = 'Select all dataElement/Categories',
                              value = FALSE )  ,

  div(id = "expr-container",
                
              selectInput("data_categories", 
                          label = "DataElement/Category" , 
                  choices = NULL  ,
                  selected = 1 ,
                  width = "100%" ,
                  multiple = TRUE ,
                  selectize = TRUE
                  ) 
            )
            )

  
# div(id = "expr-container", 
splitLayout( cellWidths = c("25%", "75%") ,
               
       checkboxInput( "dataset_merge", 
                     label ='Merge all datasets', value = FALSE ) ,
 
        
       selectInput( "merge", 
                    label ='Merge datasets with selected dataElements/Categories (averages values when reported through multiple datasets)', 
              choices = NULL  ,
              selected = 1 ,
              width = "100%" ,
              multiple = TRUE ,
              selectize = TRUE ) 
       ) 
# )
        

inputPanel(
 selectInput("level", label = "Organization Level:" ,
              choices = c( 'leaf' ) ,
              selected = NULL ) ,
 
 checkboxInput('hts', label = "Aggregate across full administrative hierarchy", 
               value = TRUE ) ,
 
 selectInput("hts_level", label = "Aggregate only from level:" ,
              choices = 2:4 ,
              selected = 2 ) ,
 
 checkboxInput( "exclude_recent_month" , label ='Exclude most recent month?',
               value = TRUE  ) 
)


# splitLayout(  cellWidths = c("55%", "45%") ,
#   textInput( "data.intervention", label = "Data intervention:", 
#              value = "" ,
#              width = '100%'
#              # , style = "font-size: 50%;"
#              ) ,
#   
#   selectInput("intervention.key", label = "Intervention key:" , 
#               choices = NULL , 
#               selected = NULL ) 
#   
# )

```


```{r Formulas }


data.folder = reactive({
  print( 'data.folder:')
  # req( input$country )
  req( input$data.directory  )
  data.dir = file.dir( # country = input$country , 
                          dir.base = input$data.directory )
  has.slash.at.end = str_locate_all( data.dir , "/") %>% 
  unlist %in% nchar( data.dir) %>% any 
if ( !has.slash.at.end  ){ data.dir = paste0( data.dir , "/" ) }

  print( 'data.folder is '); print( data.dir )
})

formula.file = reactive({ 
  req( data.folder() )

  ff = files( search = 'Formula' , dir = data.folder() )  
  if ( is_empty( ff ) ){
    print( 'no forumula files in directory' )
    return( NULL )
  } 
    
  ff = paste0( data.folder() , ff %>% most_recent_file() )
  
  print( 'formula.file' ) ; print( ff )
  if ( !any(file.exists( ff ) )) return()
  return( ff )
  })

formulas =  reactive({
  req( formula.file() )

  print( 'formula file:') ; print( formula.file() )
  
  if ( !any(file.exists( formula.file() ) )) return( NULL )
  
  formulas = read_excel( formula.file() , sheet = 'Formula') %>% 
    filter( !is.na(Formula.Name)) %>%
    arrange( Formula.Name )
  
  print( 'formulas') ; print( formulas$Formula.Name )
  
  return( formulas )
})

formula.names = reactive({ formulas()$Formula.Name })

formula_elements =  reactive({
  req( formula.file() )
  req( input$indicator )
  
  read_excel( formula.file() , sheet = 'Formula Elements')  %>%
    filter( Formula.Name %in% input$indicator )

})

observe({  updateSelectInput( session, 'indicator' , 
                              choices =  formula.names() ,
                              selected = NULL ) } )

observe({  updateSelectInput( session, 'split' , 
                              choices =  c('None', names( dataset() )) ) } )

observe({  updateTextInput( session, 'startingYear' , 
                            value  =   min( d() %>% 
                                   pull( !! rlang::sym( period() ) ) %>%
                                     year ))  
  })

```

```{r datasets}


dataset = reactive({

  req( input$dataset )
  print( 'dataset():')
  
  print("ingesting..."); 
  # showNotification( "reading data file", type = 'message' )

  
  if ( is_empty( input$dataset ) ) return( NULL )
  
  print( input$dataset )

  # testing:
  tic()
  if ( !any(file.exists( input$dataset ))) return( NULL )
  
  # RDS 
  dataset =  readRDS( input$dataset ) 
  
  print( "nrow( dataset )" ); print( nrow( dataset ) )
  print( "add dataset info from formulas")
  # glimpse( dataset )
  # glimpse( formula_elements() )
  
  dataset = dataset %>%
    as_tibble() %>%
    left_join( formula_elements() %>% 
                 select( dataElement.id  , dataSet ) %>%
                 distinct ,  
               by = 'dataElement.id' )
  
  print( "nrow( dataset )" ); print( nrow( dataset ) )
  print("done"); toc()
  # print( 'glimpse( dataset )' ); # glimpse( dataset )
  #   glimpse( formula_elements() )

  return( dataset )
  
})

dataSets = reactive({
  req( dataset() )
  dataset() %>% filter( !is.na( dataSet ) ) %>%
            pull( dataSet ) %>% unique
})

```

```{r data_selections_updates}

# update data directory/country
# observe({
#   req( input$data.directory  )
#   if ( dir.exists( input$data.directory ) ){ 
#     data.dirs = input$data.directory
#     print( 'updating country folder' )
#     updateSelectInput( session, 'country' , 
#                        choices =  list.dirs( data.dirs , recursive=FALSE) %>%
#                          basename
#     )
#   }
# } )


country_files = reactive({ 
    if ( !dir.exists( data.folder() )) return( NULL )
    dir.files = list.files( data.folder() )
    print( "dir.files : "); # print( dir.files )
    return( dir.files )
})
  
rds_data_file = reactive({
  req( country_files() )
  req( data.folder() )
  req( input$indicator )
    
  dir.files = country_files()

  indicator = paste0( "_" , input$indicator , "_" )
  print( 'indicator:' ); print( input$indicator )
  
  file.type = 'rds' # input$file.type 
  file.other = '_Seasonal' # input$file.other
  file.label = 'formulaData'
  
  all.levels.data.files = dir.files[ grepl( 'All levels' , dir.files) &
          grepl( file.type , dir.files) &
          grepl( file.other, dir.files, fixed = TRUE  ) &
          grepl( file.label, dir.files, fixed = TRUE  )]

  print('all levels data files:') ; print( all.levels.data.files )
  
  f.indicator = grepl( indicator , all.levels.data.files , fixed = TRUE )
  
  print("f.indicator:" ) ;  print( f.indicator ) 
  
  if ( sum( f.indicator ) == 0 ) return( NULL )
  
  if ( !dir.exists( data.folder() )) return( NULL )
  
  data_file = paste0( data.folder() , all.levels.data.files[f.indicator]  )  # %>% most_recent_file()
  
  print( 'data_file is'); print( data_file )
  
  if ( !any(file.exists( data_file ))) return( NULL )

  print( "data file exists =" ); print( any(file.exists( data_file )) )
  return( data_file )

})


xlxs_data_file = reactive({
  req( country_files() )
  req( input$indicator )

  dir.files = country_files()

  indicator = input$indicator
  print( 'indicator:' ); print( input$indicator )

  file.type = 'xlxs' # input$file.type
  file.other = '' # input$file.other

  all.levels.data.files = dir.files[ grepl( 'All levels' , dir.files) &
                                       grepl( file.type , dir.files) &
                                       grepl( file.other, dir.files, fixed = TRUE  )]

  print('all levels data files:') ; print( all.levels.data.files )

  f.indicator = grepl( indicator , all.levels.data.files , fixed = TRUE )
  print("f.indicator:" ) ;  print( f.indicator )

  if ( sum( f.indicator ) == 0 ) return( NULL )

  if ( !dir.exists( dir() )) return( NULL )

  data_file = paste0( dir() , all.levels.data.files[f.indicator]  )  %>% most_recent_file()

  if ( !file.exists( data_file )) return( NULL )

  print( "data file:" ); print( data_file )
  return( data_file )

})

# Update list of data files
observe({  updateSelectInput( session, 'dataset' , 
                              choices = rds_data_file() , 
                              selected = rds_data_file()[1] ) 
  } )

# Update list of datasets
observe({
  print( 'updating merge dataSets input' )
  req( dataSets() )
  if ( any( nchar( dataSets() > 0 ) ) ){ 
    updateSelectInput( session, 'merge' , 
                       choices =  dataSets() 
    )
  }
} )

observeEvent( input$dataset_merge , {
  print( 'updating merge dataSets to all' )
  req( dataSets() )
  if( input$dataset_merge == TRUE ){
  if ( any( nchar( dataSets() > 0 ) ) ){ 
    updateSelectInput( session, 'merge' , 
                       choices =  dataSets() ,
                       selected = dataSets() )
  }
  } else {
    updateSelectInput( session, 'merge' , 
                       choices =  dataSets() ,
                       selected = NULL
    )
  }
} )

# update data_categories
observe({
  print( 'updating data_choices' )
  updateSelectInput( session, 'data_categories' ,
                     choices =   unique( dataset()$data ) ,
                     selected = 1 )
} )

observeEvent( input$all_categories , {
  print( 'updating data_categories to all' )
  if( input$all_categories == TRUE ){
  updateSelectInput( session, 'data_categories' , 
                     choices =   unique( dataset()$data ) ,
                     selected = unique( dataset()$data ) ) 
  } else {
    updateSelectInput( session, 'data_categories' , 
                     choices =   unique( dataset()$data ) ) 
  }
} )

most_recent_period = reactive({
  req( period() )
  print( 'most_recent_period' ); print( period() )
  print( names( dataset() ))
  mrp = max( dataset() %>% 
               pull( !! rlang::sym( period() ) ), na.rm = TRUE ) 
  # mrp = max( dataset()[ , 'Month'] , na.rm = TRUE ) 
  # mrp = max( dataset()$Month , na.rm = TRUE ) 
  print( 'most recent period is'); print( mrp )
  
  # if ( input$exclude_recent_month ){
  #   if ( period() == "Month" ) mrp = mrp - month(1)
  #   if ( period() == "Week" ) mrp = mrp - week(1)
  # } 
  
  print( 'mrp:') ; print(mrp)
  return( mrp )
})

period = reactive({
  print('period():')
  req(dataset())

  weekly = any( map_lgl( dataset() , 
                         ~any(class(.x) %in% 'yearweek'  )) )
  
  period = ifelse( weekly, "Week", "Month" )
  print('end period()'); print( period )
  return( period  )
})




```

```{r data}

d = reactive({

  req( dataset() )
  req( period() )
  print( 'd:')
  
  .period = period()
  data = dataset()  %>% mutate( period = !!rlang::sym( .period ))
  
  
  if ( !is_empty( input$level2 ) ){
    print( paste( 'filtering data by' , levelNames()[2] , "=" , input$level2 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[2])  %in%   input$level2  )
    
    print( paste( 'data filtered by level2 has' , nrow( data ), 'rows' ))
    # glimpse( data )
  }
  
    if ( !is_empty( input$level3 ) ){
    print( paste( 'filtering data by' , levelNames()[3] , "=" , input$level3 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[3])  %in%   input$level3  )
    
    print( paste( 'data filtered by level3 has' , nrow( data ), 'rows' ))
    # glimpse( data )
    }
  
if ( !is_empty( input$level4 ) ){
    print( paste( 'filtering data by' , levelNames()[4] , "=" , input$level4 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[4])  %in%   input$level4  )
    
    print( paste( 'data filtered by level4 has' , nrow( data ), 'rows' ))
    # glimpse( data )
}
  
if ( !is_empty( input$level5 ) ){
    print( paste( 'filtering data by' , levelNames()[5] , "=" , input$level5 ) )
    data = data %>% 
      filter( !! rlang::sym( levelNames()[5])  %in%   input$level5  )
    
    print( paste( 'data filtered by level4 has' , nrow( data ), 'rows' ))
    # glimpse( data )
  }
  
  print( 'nrow( d )' ); print( nrow( data ))
  
  if ( input$level %in% 'leaf'){  
    data = data %>% filter( effectiveLeaf == TRUE )
  } else {
    data = data %>% filter( levelName  %in% input$level  )
  }
  
  # if ( input$exclude_recent_month ) data = data %>% 
  #   filter( !! rlang::sym( period() ) <= most_recent_period() )
  
  if ( input$source %in% 'Original' ){
    data = data %>% mutate( dataCol = original )
  }  
  
  if ( input$source %in% 'Cleaned' ){
    print( paste('cleaning removes', sum( data$value , na.rm = T ) - sum( data$seasonal3 , na.rm = T )  , 'data points' ) )
    data = data %>% mutate( dataCol = ifelse( seasonal3, original, NA  ) )

    print( paste('cleaning changes total by', sum( data$original , na.rm = T ) - sum( data$dataCol , na.rm = T )) )
  }  
  
  # print( 'd: max period ' ); print( max( d$period ))
  print( 'd: max period ' ); 
  print( max( data %>% pull( period  ) , 
              na.rm = TRUE ))
  # print( max( data$Month , na.rm = TRUE ))
  
  # Modify variables used for cleaning data so that FALSE when NA -- meaning it failed prior cleaning step, and TRUE means data is ok
  if ('mad15' %in% names( data )) data = data %>% mutate( mad15 = ifelse( value & is.na( mad15)|!mad15, FALSE, TRUE ) )
  if ('mad10' %in% names( data )) data = data %>% mutate( mad10 = ifelse( value & is.na( mad10)|!mad10, FALSE, TRUE ) )
  if ('mad5' %in% names( data )) data = data %>% mutate( mad5 = ifelse( value & is.na( mad5)|!mad5, FALSE, TRUE ) )
  if ('seasonal5' %in% names( data )) data = data %>% mutate( seasonal5 = ifelse( value & is.na( seasonal5)|!seasonal5, FALSE, TRUE ) )
  if ('seasonal3' %in% names( data )) data = data %>% mutate( seasonal3 = ifelse( value & is.na( seasonal3)|!seasonal3, FALSE, TRUE ) )
    
  print( 'end d()' )
  return( data )
})

```

Reporting 
====================================

Row 
-------------------------------------

```{r data.reports}


orgunit.reports = reactive({ 
  req( input$data_categories )
  req( most_recent_period() )
  req( period() )
  
  print( 'orgunit.reports()' )
  
  mrm = most_recent_period()
  
  year_var = 'calendar_year' # ifelse( input$calendar_year , 'calendar_year' , 'months12' )
  
  data = d()
  
  if ( !input$count.any & !input$all_categories )  data = 
    data %>% filter( data %in% input$data_categories )
    
  .period = period()

  o.r. = 
    data %>% as_tibble() %>% ungroup %>%
    
    mutate(

    calendar_year = year( !! rlang::sym( .period )  )
     
  ) %>%
  rename( year =  {{ year_var }} ) 
  
    
  o.r. = setDT(o.r.)[, .( n_periods = uniqueN( get( .period ) )), 
                   by = c( 'year' , 'orgUnit' ) ] %>%
    as_tibble() %>%
  # group_by( year , orgUnit ) %>%
  # summarise( n_periods = n_distinct( !! rlang::sym( period() )  ) 
  #            # , max_month = max( Month ) 
  #            ) 
  mutate( n_periods = factor( n_periods ) ,
          year = factor( year ) )
  
  #print( 'o.r:') ; # print(head(o.r))
  print( 'end orgunit.reports' )
  return(o.r.)
})

annual.reports = reactive({ 
  req( orgunit.reports() )
  print( 'annual reports()' )
  
  or = orgunit.reports() 
  # print( 'annual reports() or:' ); print( names(or))
  
  ar = setDT(or)[, .( n = .N ), 
                   by = c( 'year' , 'n_periods' ) ] %>%
    as_tibble()
  
  # group_by( year ,  n_periods ) %>%
  # summarise( n = n() )
  print( 'end annual reports' )
  return( ar )
})

orgunit.monthly.reports = reactive({ 
  req( input$data_categories )
  print( 'orgunit.monthly.reports():' )
  
  # mrp = most_recent_period()
  .period = period()
  
  year_var = 'calendar_year' # ifelse( input$calendar_year , 'calendar_year' , 'months12' )
  
  data = d()
  
  if ( !input$count.any & !input$all_categories   ) data = data %>% filter( data %in% input$data_categories )
  
  o.m.r = 
    data %>% as_tibble() %>% ungroup %>%

    mutate(
           calendar_year = year( !! rlang::sym( .period )  )
     
  )  %>%
  rename( year =  {{ year_var }} ) 
  # %>%
  # mutate( year = factor( year ) )

  print( 'end orgunit.monthly.reports()' )
  # print(head(o.m.r))
  return(o.m.r)
})

monthly.reports = reactive({ 
  req( orgunit.monthly.reports() )
  req( period() )
  print( 'monthly reports():' )
  
  .period = period()
 
  o.m.r = orgunit.monthly.reports() 
  
  # print('monthly.reports() o.m.r'); print( names(o.m.r) )
  
  m.r = setDT(o.m.r)[, .( n = uniqueN( orgUnit ) ), 
                   by = c( "year" , .period  ) ]  %>%
    as_tibble()
  
  # group_by( year , !! rlang::sym( .period )   ) %>%
  # summarise( n = n_distinct( orgUnit ) )
  
  # print('m.r') ; glimpse(m.r)
  print( 'end monthly reports()' )
  # glimpse( m.r)
  return(m.r)
})


facilities = reactive({
  print( 'facilities' )
  req( orgunit.reports() )
  
  f = orgunit.reports() %>%
  ungroup() 
  
  f = setDT(f)[, .( Total = uniqueN( orgUnit ))] %>%
    as_tibble() %>%
    # summarise( Total = n_distinct( orgUnit ) ) %>%
    pull( Total)
  
  print( 'end facilities' )
  return(f)
})

```

```{r selectedOus }

selected <- reactiveValues( x  = NULL, panel = NULL , chart = NULL )

observeEvent( input$plot1_brush  , {
  # glimpse( input$plot1_brush )
  selected$chart = 1
  
  selected$x = round( 
    seq( input$plot1_brush$xmin , input$plot1_brush$xmax , by = .5 )
  ) %>% unique 
  
  selected$panel = input$plot1_brush$panelvar1
      
  print( "plot1 selected$x:" ) ;  print( paste( selected$x , selected$panel ) )
  return( selected )
})

observeEvent( input$plot2_brush  , {
  # glimpse( input$plot1_brush )
  selected$chart = 2
  
  selected$x = round( 
    seq( input$plot2_brush$xmin , input$plot2_brush$xmax , by = .5 )
  ) %>% unique %>% as.integer()
  
  selected$panel = input$plot2_brush$panelvar1
      
  print( "plot_2_selected$x:" ) ;  print( selected$x ) ; print( selected$panel ) 
  return( selected )
})

selectedOUs <- reactive({
  print( 'selectedOUS()' )
  tic()
  req( input$endingMonth )
  
  if ( input$mostReports ){
     print( "determining most frequently reported facilities..." ); 
     print(input$startingMonth  ) ; print( input$endingMonth )
    
    data = d()
    
    if ( !input$count.any & !input$all_categories  ){
        print( input$all_categories )
        data = data %>% filter( data %in% input$data_categories )
     }

     if ( period() %in% 'Month' ){
       data = data %>% as_tibble %>%
       filter( 
         period >=  yearmonth( input$startingMonth )  ,
         period <=  yearmonth( input$endingMonth )  
               )
     } 
    
     if ( period() %in% 'Week' ){
       data = data %>% as_tibble %>%
       filter( 
         period >=  yearweek( input$startingMonth )  ,
         period <=  yearweek( input$endingMonth )  
               )
     } 
    
     mr = data %>% 
       distinct( !! rlang::sym( period() ) , orgUnit ) %>%
       group_by( orgUnit ) %>%
       summarise( n = n() ) %>%
       arrange( desc( n ))
     
     print( "mr" ); print( summary( mr$n ) )

     s = mr %>%
       filter( n == max( mr$n ) ) %>%
       pull( orgUnit ) %>% unique
     
     print( "mostReports selectedOUs:" ); toc() ##print( selectedOUs )
     return( s )
     }
  
  if( is.null( selected$x ) ) return( NULL )
  
  if ( selected$chart == 1 ){
      select_month =  as.numeric( orgunit.reports()$n_periods ) %in% selected$x
      selectedRows = select_month &
         orgunit.reports()$year %in% selected$panel 
      s = orgunit.reports()[ selectedRows, ]$orgUnit %>% unique
      
      

    } else {
      select_month = month( orgunit.monthly.reports() %>%
                              pull( !! rlang::sym( period() ) ) ) %in% selected$x
      selectedRows = select_month &
        year( orgunit.monthly.reports() %>%
                pull( !! rlang::sym( period() ) ) ) %in% selected$panel
      s = orgunit.monthly.reports()[ selectedRows, ]$orgUnit %>% 
        unique
      
      
    }

      print( "end selectedOUs:" ); toc()  # print( selectedOUs )
      return( s )
    })
  
x.annual = reactive({
  print( 'x.annual()' )
  tic()
  x.a = orgunit.reports() %>% 
        filter( orgUnit %in% selectedOUs() )   # %>%  
        # group_by( year , n_periods ) %>%
        #   summarise( n =  n_distinct( orgUnit ) )
  
  # data.table speed up over dplyr
  x.a = setDT(x.a)[, .( n = uniqueN( orgUnit )), 
                   by = c( 'year' , 'n_periods' ) ]  %>%
    as_tibble()

  print('end x.annual:') ; toc();  # print( x.a )
  return( x.a )
  
})

x.months = reactive({
  # req( keeprows() )
  tic()
  print( 'x.months()' )
  
  .period = period()
  
  x.m = orgunit.monthly.reports() %>% 
        filter( orgUnit %in% selectedOUs() ) 
  
  x.m = setDT(x.m)[, .( n = uniqueN( orgUnit )), 
                   by = c( 'year' , .period )   ]  %>%
    as_tibble()
  
  
  # %>%
  #       group_by( year , !! rlang::sym( period() )  ) %>%
  #       summarise( n = n_distinct( orgUnit ) )
  
  print('end x.months:') ; toc() ; # glimpse( x.m )
  return( x.m )
  
})


```
  

### Number of Facilties Reporting each Period (plot_reporting_by_month)

```{r}
plotOutput( 'plot_reporting_by_month' , 
    click = "plot2_click" ,
    dblclick = "plot2_dblclick" ,
    hover = "plot2_hover" ,
    brush = "plot2_brush" )

```


```{r plot_reporting_by_month }

plot2 = reactive({
  req( monthly.reports() )
  print('plot2():')
  .period = period()
  
  # save data for testing ggplot options
  saveRDS( monthly.reports(), 'plot2_data.rds' )
  
  if ( length( monthly.reports()$year) > 0  ) {
  
  if ( .period == "Month" ){
            .breaks = 1:12
  } else {
            .breaks = seq(2, 53, 4)
  }

  g = ggplot( monthly.reports() %>% mutate( facilities = 'All' ), 
              aes( x =  !! rlang::sym( .period ) 
                   , y = n  
                   , group = facilities
                   , color = facilities 
                   ) ) +
    # geom_col() +
    geom_point( ) +
    geom_line( ) +
    geom_hline( yintercept = facilities() ) +
    facet_wrap( ~ year , scales = 'free_x') +
    # scale_x_discrete( .period 
    #                     , breaks = .breaks
    #                     # , labels  = as.character( .breaks )
    #                     )  +
    ylim( 0 , NA ) +
    scale_color_manual( values = c( 'All' = 'black' , 
                                    'Selected'= 'brown' ) ) +
    scale_fill_manual( values = c( 'All' = 'black' , 
                                    'Selected'= 'brown' ) ) 

  if (!is.null( selectedOUs() ) ){
    g = g + 
      # geom_col(  data = x.months() %>% mutate( facilities = 'Selected' )  ) 
      geom_point( data = x.months() %>% mutate( facilities = 'Selected' ) ) +
      geom_line( data = x.months() %>% mutate( facilities = 'Selected' ) )
    }
  
  return( shift_legend3(g) )
  # return( g )
  }
  
  print('end plot2')
  return( g )
})

output$plot_reporting_by_month <- renderPlot({  plot2()  })

```



```{r plot_brush, eval = FALSE }

verbatimTextOutput("info")

output$info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             " ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }

    paste0(
      "click: ", xy_str( input$plot1_click ),
      "dblclick: ", xy_str(input$plot1_dblclick),
      "hover: ", xy_str(input$plot1_hover),
      "brush: ", xy_range_str(input$plot1_brush)
    )
  })

```


```{r html_text, eval=FALSE }

htmlOutput("x_value")
      
```


```{r selected_text}

 # Print the name of the x value
  output$x_value <- renderText({
    
    if ( input$mostReports ){ 
      HTML("You've selected <code>" , comma( length( selectedOUs() ) ), "facilities" , 
           "</code>" )
    }
    
    if ( is.null( selected$x ) ) return("")
    
    else {
      lvls <- levels( annual.reports()$n_periods )
      panel = selected$panel
      
      name <- lvls[ round( selected$x ) ]
      HTML("You've selected <code>" , comma( length( selectedOUs() ) ) , 
           "</code>" ,
           "facilities that submitted data for <code>", 
           paste( name, collapse = "," ) , 
           "months during", panel , 
           "</code>" )
    }
  })

```

### Histogram of Annual Number of Months Reported (plot_reports_in_a_year)

```{r}
plotOutput( 'plot_reports_in_a_year' , 
    click = "plot1_click" ,
    dblclick = "plot1_dblclick" ,
    hover = "plot1_hover" ,
    brush = "plot1_brush" )

```

```{r plot1 }

plot1 = reactive({
  print( 'plot1():' )
  req( annual.reports() )
  req( period() )
  .period = period()
  
  # save data for testing ggplot options
  saveRDS( annual.reports() , 'plot1_data.rds' )
  
  
  if ( length( annual.reports()$year) > 0  ) {
    
  if ( .period == "Month" ){
            .breaks = 1:12
  } else {
            .breaks = seq(2, 53, 4)
  }
    
  g = ggplot( annual.reports() , 
              aes( x = n_periods , y = n ) ) +
    geom_col() + 
    scale_x_discrete( 'Number Months Reported' 
                      , breaks = .breaks   
                      , labels  =  .breaks
                      )  +
    geom_hline( yintercept = facilities() ) +
    facet_wrap( ~ year , scales = 'free_x')
  
  if (!is.null( selectedOUs() ) ){
    g = g + geom_col( data = x.annual() , fill = 'brown' ) 
  }

  print( 'end plot1' )
  return(g)
  }
})

output$plot_reports_in_a_year <- renderPlot({  plot1()  })

```

Row 
-------------------------------------
  

### Values (plot_values)


```{r plotAgregateValue  }

plotOutput( 'plot_values' ,
    hover = "plotSelectedOusValues_hover" ,
    brush = "plotSelectedOusValues_brush"
    )

plotData = reactive({
   print( 'plotData():')
   req( d() )
   req( input$data_categories )
  
    data = d() %>%
      mutate( Selected = 'All' )
    
    # filter to selected category
    print( 'plotData filtered by' ); print( input$data_categories )

    if ( !input$all_categories )  
      data = data %>% filter( data %in% input$data_categories )
    
    # Add var for selected ous
    print( 'length( selectedOUs()) ' ); print( length( selectedOUs())  )
    
   if ( length( selectedOUs()) > 0 ) data  = data %>%
      mutate( Selected = ifelse( 
        orgUnit %in% selectedOUs() , 
        'Reporting Each Period', 
        'Inconsistent Reporting' )
      )
    
    print( 'end  plotData()')  ; # print( names( data )) 
  return( data )
})

group_by_cols = reactive({
    # req( input$split )
    print( "group_by_cols():")
    group_by_cols =  c( period() , 'orgUnit', 'Selected',
                        'dataSet' ) 
    
    group_by_cols = c( group_by_cols, levelNames() )
  
    
    if ( input$split != 'None' ) group_by_cols = c( group_by_cols , input$split )
    
    # if ( length( selectedOUs() > 0 ) ) 
      # group_by_cols = c( group_by_cols , 'Facilities' )
    
    # # If not merge when total, show separate datsets
    # if ( !input$merge & input$all_categories ) group_by_cols = c( group_by_cols , 'dataSet' )
    #   
    print( "end group_by_cols()") ; print( unique( group_by_cols )  )
    return( unique( group_by_cols ) )

})

data.total = reactive({
  req( plotData() )
  # req( group_by_cols() )
  req( period() )
  print( 'data.total():')

  
  .period = period()
  # if ( input$merge & input$all_categories ){
    
    .group_by_cols =  group_by_cols()  
    # print( '.group_by_cols:' ) ; print( .group_by_cols )

    # Total categories by facilities and datasets
    data = plotData() 
    # %>% 
    #   group_by(  !!! dataset_group_by_cols  ) 
    print( 'setDT(data):' )
    
    
    # testing exogenous regressors
    if (input$covariates %in% c( 'ipti' , 'doses' ) ){
      data = setDT(data)[ , .( total = sum( dataCol , na.rm = TRUE  ) ,
                               doses = sum( doses, na.rm = TRUE ) ,
                               ipti = sum( ipti, na.rm = TRUE )
                               ) ,
                           by = .group_by_cols ] %>% 
      as_tibble()
    } else {
          
      data = setDT(data)[ , .( total = sum( dataCol , na.rm = TRUE  ) ) ,
                           by = .group_by_cols ] %>% 
      as_tibble()
    }
    
    # Merge  datasets 
    # Set all dataSets to Combined and re-summaries taking mean
    # print( 'data.total datasets' );  print( dataSets() )
    # print( 'input$merge ') ; print( input$merge )
    # print( 'data datsets ' ) ;  print( unique(data$dataSet) %>%                                        str_replace_all(fixed("\r"), ""))
    
    merge = length( input$merge ) > 1 
    if ( merge ){
      print( 'merging datasets' )

      # MErge datasets
      dataMerge = data %>%
        mutate( dataSet = dataSet %>% str_replace_all(fixed("\r"), "") ) %>%
        filter( dataSet %in% input$merge ) %>%
        mutate( dataSet = 'Combined' ) 
 
      # data.table sum
      print( 'merge data.table sum') ; 
      dataMerge = setDT( dataMerge )[ , .(total = mean( total , 
                                             na.rm = TRUE  )) ,
                           by = .group_by_cols ] %>% 
        as_tibble()
      
      print( 'dataMerge done' );  # glimpse( dataMerge )
      
      dataNotMerge = data %>%
        mutate( dataSet = dataSet %>% 
                  str_replace_all(fixed("\r"), "") ) %>%
        filter( ! dataSet %in% input$merge ) 
      
      # print( 'dataNotMerge' );  glimpse( dataNotMerge )
      
      if ( nrow( dataNotMerge ) > 0 & input$dataset_merge ){
        
       data = bind_rows( dataMerge ,
                         dataNotMerge %>%
                           mutate( dataSet = 'Combined' )
                         )  

       data = setDT( data )[ , .(total = sum( total , na.rm = TRUE  ) ) ,
                    by = .group_by_cols ] %>%
         as_tibble()

       } else  {
        data  = bind_rows( dataMerge , dataNotMerge )
        print( 'data.total duplicates' )  
        # saveRDS( data, 'data.rds' )
        # print( data %>% duplicates %>% glimpse )
          } 
    }

  
  print( 'data.total key_cols:')
  
  key.cols = setdiff( group_by_cols() , .period ) 
      
  # print( key.cols )
  
  data.total = 
      data %>% 
      as_tsibble( index = !! rlang::sym( .period )  , 
                  key =  all_of(  {{key.cols}} ) ) %>%
      # fill_gaps( .full = TRUE  ) %>%
      mutate( 
              total = replace_na( total , 0) 
              )  # for plotting, replace missing with zero 
  
  print( 'data.total finalized' ); # print( toc())

  # test:
  saveRDS( data.total, 'data.total.rds')
  
  return( data.total )
    

})

num_facilities = reactive({
  req( data.total() )
  print('num_facilities()')
  .d = data.total()
  l = length( unique( .d$Selected ) )
  print( paste( 'number of Facilities', l ) )
  return( l )
})

num_datasets = reactive({
  req( data.total() )
  print('num_datasets()')
  .d = data.total()
  l = length( unique( .d$dataSet ) )
  print( paste( 'number of dataSets', l ) )
  return( l )
})

hts = reactive({   
  print( "hts():" )

  
  adms = backtick( levelNames() )
  
  if (input$hts){ 
    hts = paste( adms, collapse = "/" ) 
  } else {
    hts = paste( adms[1:as.integer(input$hts_level)] , 
                 collapse = "/" ) 
  }
  
  hts = paste( "(" , hts , ")" )
  
  # if >1 Facilities (ie. selected)
  if ( num_facilities() > 1 )  hts = paste( 
           'Selected *' , hts 
           )
  
  # if >1 dataset 
  if ( num_datasets() > 1 )  hts = paste( 
           'dataSet *' , hts
           )
  
  # # Cross by split
  if ( !input$split %in% 'None' ) hts =
    paste( input$split , '*' ,  hts )
  # 
  # Cross by selected and split
  # if ( length( selectedOUs() ) > 0  & !input$split %in% 'None' ) hts =
  #   paste( input$split ,  ' * Facilities * (', hts , ')' )
  
  print( "end hts():" ); print( hts )

  return( hts )
})

data.hts = reactive({
  req( data.total() )

  print( 'data.hts():' );   tic()

  .d = data.total()
  
  # testing exogenous vaiables
  if ( input$covariates %in% c('ipti' , 'doses' ) ){
    .d = .d %>%
    aggregate_key(  .spec = !!rlang::parse_expr( hts() ) ,
                    total = sum( total , na.rm = T ) ,
                    ipti = sum( !!rlang::parse_expr( 'ipti' ) , na.rm = T ) ,
                    doses = sum( !!rlang::parse_expr( 'doses' ) , na.rm = T )
                    ) 
  } else {
      .d = .d %>%
    aggregate_key(  .spec = !!rlang::parse_expr( hts() ) ,
                    total = sum( total , na.rm = T )
                    ) 
  }
  
  print( 'end data.hts():' ) ; toc()
    return(.d)
})

aggregatePlotData = reactive({
   req( data.hts() )
   print( 'aggregatePlotData():' )
  
  .d = data.hts() %>% 
      filter( 
        ! is.na( !! rlang::sym( levelNames()[1] ) )
        , is_aggregated( !! rlang::sym( levelNames()[1] ) )
      ) %>%
       mutate( 
         grouping_var = 'Total' )
     
     if ( num_datasets() > 1 ){
       print( 'num_datasets()>1:') ;
       .d = .d %>% 
       filter( !is_aggregated( dataSet ) ) %>%
       mutate( dataSet = as.character( dataSet ) %>%
           str_remove_all( "<aggregated>" ) ,
           grouping_var = dataSet )
       print( unique(.d$dataSet))
     }  
     
     if ( num_facilities() > 1 ){
       print( 'num_facilities()>1:') ; 
       .d = .d %>% 
       filter( !is_aggregated( Selected )  ) %>%
       mutate( Selected = as.character( Selected ) %>%
           str_remove_all( "<aggregated>" )  )
       
       print( unique(.d$Selected))
     }  
        
    # if split, remove aggregate grouping
     if ( !input$split %in% 'None' ){
       print( '!input split none') ; print( input$split )
       .d = .d %>%
         filter( !is_aggregated( !! rlang::sym( input$split ) ) 
         ) %>%
         mutate( grouping_var = as.character( 
           !! rlang::sym( input$split ) )
         )
       print( unique(.d$grouping_var) )
       # print( glimpse( .d ))
       
     } 
     
     print( 'end aggregatePlotData()' )
     return( .d )
 
})

 caption.text =  reactive({
    paste( 
      ifelse( selectedOUs() > 0 , 
           paste( comma( length( selectedOUs() ) ), 'facilities' ) ,
           "" ) ,
    ifelse( nchar( input$level2 ) > 0, paste( input$level2 , collapse = "+" ) ) ,
    ifelse( nchar( input$level3 ) > 0, paste(  "/" , input$level3 , collapse = "+" ) ) ,
    ifelse( nchar( input$level4 ) > 0, paste(  "/" , input$level4, collapse = "+"   ) ) ,
    ifelse( nchar( input$level5 ) > 0, paste(  "/" , input$level5, collapse = "+"   ) )
                         )
  })

plotAgregateValue = reactive({
  
  req( aggregatePlotData() )
  req( input$split )
  print( 'plotAgregateValue():' )

  .d = aggregatePlotData()
  
  saveRDS(.d, 'plot3_data.rds')
  
  data.text = paste( unique( plotData()$data ),
                     collapse = " + " ) 
  
  # print( 'data.text'); print( data.text )
  
  .limits = c(0, NA)
  
     
  print('plotting aggregate data');
  

  g = .d %>% 
    fill_gaps( .full = TRUE  ) %>%
    # autoplot( vars( total , grouping_var ) )
    ggplot( aes(x = !! rlang::sym( period() ) , y = total
             , group = grouping_var  
             , colour =  grouping_var
            ) )  +
      geom_line()
  
  # Line color for mulitple datasets
  if ( num_datasets() > 1 ){
    print( 'unique dataSets'); print( unique( .d$dataSet ) )
    dataSet_breaks = unique( .d$dataSet )
    datSet_labels =  unique( .d$dataSet )
    datSet_labels[ datSet_labels == "" ] = "Combined"
    
    g = g +
    scale_color_discrete( breaks = dataSet_breaks ,
                          labels =  datSet_labels ,
                          drop = TRUE ) +
    guides(color=guide_legend(title="dataSet"))
    
  } else {
     g = g + guides( color = "none" )
  }
  
  # Split data
  if ( !input$split %in% 'None' ){
    g = g + guides(color=guide_legend(title= input$split ))
  }

  
  # facet when selected > 0
  if ( length( selectedOUs() ) > 0 ) g =
  g + facet_wrap( vars( Selected ) ,
                  scales = 'free' , ncol = 3 ) 
  
  # Time scales
  if ( period() %in% 'Month' )  g = g + 
    scale_x_yearmonth( date_breaks = "1 year" )
  if ( period() %in% 'Week' )  g = g + 
    scale_x_yearweek( date_breaks = "1 year" )
  
  g = g +
    scale_y_continuous( label=comma, limits = .limits ) +
    labs( y = "" , x="" ,
          title = str_wrap( input$indicator , 200 ) ,
          subtitle = str_wrap( data.text , 200 ) 
          , caption =  str_wrap( caption.text() , 200 )
          ) +
    theme_minimal()  
    
  print( ' end plotAgregateValue()' )

  return( g )
})

output$plot_values <- renderPlot({  plotAgregateValue()  })

```




Map 
====================================

Row 
-------------------------------------
  
### Map {.no-padding }

```{r ous }


ous.file = reactive({
  req( data.folder() )
  print( 'ous.file(): ')
  
  dir = data.folder() 
  
  if ( file.exists( paste0( data.folder() , 'newOUS.rds')  ) ){
     
    f = paste0( dir,'newOUS.rds'  )
    
    } else {
    
    print( 'looking for geofeatures file' )
    dir.files = list.files( dir )
    ous.files = dir.files[ grepl( 'geoFeatures' , dir.files,
                                              fixed = TRUE  )]
    
    print( "ous.files:" ) ; print( ous.files )
    if (  is_empty(ous.files) ){
      cat("WARNING: missing file geoFeatures.rds or newOUS.rds ")
    } 
  
    f = paste0( dir, most_recent_file( ous.files ) )
    }
    
    print( 'ous file:' ) ; print( f )
    
    if ( !any(file.exists( f ) )  ) return( NULL )
    
    return( f )
})

ous = reactive({  print( 'reading ous file' ) ; 
  req( ous.file() )
  if ( !any(file.exists( ous.file() ) )) return( NULL )
  # showNotification("reading geo features file")
  tic()
  o = readRDS( ous.file() )  
  print( 'finished reading ous file' ) ; toc() 
  print( ' OUS: ' ) ; # print( glimpse( o ))
  return( o )
  })

levelNames = reactive({ 
  req( ous() )
  print( 'levelNames():' )
  l = count( ous() %>% as_tibble, level, levelName ) %>% 
    arrange( level ) %>% pull(levelName ) 
  l = l[ !is.na(l) ]
  print( 'end levelNames():' )
  return(l)
})

levels = reactive({ 
  print( 'levels():' )
  levels = 
    count( ous() %>% as_tibble, level, levelName ) %>% 
    arrange( level ) 
  print( "levels()"); print( levels )
  return( levels )
  print( 'end levels():' )
})

observeEvent( levelNames(), 
              updateSelectInput( session, 'level' , 
                                 choices = c('leaf',
                                             levelNames() ) , 
                                 selected = 'leaf' )
              )





```

```{r eval = FALSE }

  verbatimTextOutput("selected_rows")

  # Print the rows of the data frame which match the x value
  output$selected_rows <- renderPrint({
    if ( is.null( selectedOUs() ) ) return()
    else {
      head( orgunit.reports() %>% 
              filter( orgUnit %in% selectedOUs() ), 10) #
    }
  })
```

```{r map1 , eval = TRUE }

checkboxInput( "show_map", label ='Display map (may take a minute...)', 
               value = FALSE ) 

plotOutput( 'map' , 
    click = "map1_click" ,
    dblclick = "map1_dblclick" ,
    hover = "map1_hover" ,
    brush = "map1_brush" )


hf = reactive({ ous() %>% filter( feature %in% "POINT"  ) })
admins = reactive({ ous() %>% filter( feature %in% c('MULTIPOLYGON', 'POLYGON') ) })
fs_selected = reactive({ ous() %>% filter( orgUnit %in% selectedOUs() ) })

# split_geofeatures = reactive({ split( ous() ,  ous$levelName ) })
# levels = names( split_geofeatures )
# not_all_empty_geo = map_lgl( split_geofeatures ,
#                                  ~!all(is.na(st_dimension(.x))) )
map1 = reactive({ 
  
  req( admins())
  req( hf())
  
  if ( input$show_map ){
    ggplot( ) + 
    geom_sf( data = isolate( admins() ) ) +
    geom_sf( data = isolate( hf() ) , alpha = .25 ) +
    geom_sf( data = fs_selected() , color = 'brown' ) +
    theme_ipsum()
  } else { NULL }
  
})

output$map<-renderCachedPlot({ map1() } ,
                              cacheKeyExpr = { list( #input$country , 
                                                     input$show_map , 
                                                     fs_selected() )
                                } ) 

```

```{r leaflet , eval = FALSE }
library( leaflet )
leafletOutput( 'map1' )

map1 = reactive({ 
    split_geofeatures = split( ous() ,  ous()$levelName )
    
    levels = names( split_geofeatures )
    
    # fs = ous  
    
    # mapview( fs )
    
    # # test for empty geometry
    not_all_empty_geo = map_lgl( split_geofeatures ,
                                 ~!all(is.na(st_dimension(.x))) )
    # 
    # # print( paste( 'not_all_empty_geo: ', not_all_empty_geo ) )
    # 
    # print( levels )
    # 
    n_levels = sum( not_all_empty_geo )
    # 
    colors = RColorBrewer::brewer.pal(n_levels, 'Pastel1')
    names( colors ) = levels[ not_all_empty_geo ]
    # colors = topo.colors(10)[ n_levels ] 
    # 
    # 
    m_list = map( levels[ not_all_empty_geo ] ,
                  ~ mapView( split_geofeatures[ .x ] ,
                            col.regions = colors[ .x ]
                  ) )

    m = reduce( m_list , `+`)

    m@map
})

output$map1<-renderLeaflet({ map1() } ) 
```

```{r map_brush, eval=FALSE }
verbatimTextOutput("Map.info")

output$Map.info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             " ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }

    paste0(
      "click: ", xy_str( input$map1_click ),
      "dblclick: ", xy_str(input$map1_dblclick),
      "hover: ", xy_str(input$map1_hover),
      "brush: ", xy_range_str(input$map1_brush)
    )
  })
```


Quality
====================================

Row
-------------------------------------


```{r print_mad, include = FALSE , eval=FALSE }

htmlOutput("mad_value")

 # Print the MAD value
  output$mad_value <- renderText({
    
    req( input$mad )
    

      HTML("You've selected a MAD cutoff <code>", 
           input$mad, 
           "for extreme values", 
           "</code>")

  })


```


### Extreme Outliers 

```{r dTs.extreme, eval=FALSE }



pb = NULL
# .total = reactive({ length( key_size( dTs() ) ) })
# pb <- progress_bar$new( 
#     format = ":current :percent  [:bar] :elapsedfull",
#     total = .total() , clear = FALSE, width= 50 )

mad = reactive({ input$mad })

dTs.extreme = reactive({ 
  
  print( 'dTs.extreme ... ' )
  print( paste( 'MAD is ', mad() ) )
  
  dtse = 
    d() %>%
    filter( orgUnit %in% selectedOUs() ) %>%
    as_tsibble( index = period, key = orgUnit ) %>% 
    pivot_wider( id_cols = c( orgUnit , period ) , 
                 names_from = "vars", 
                 values_from = "dataCol" ) %>%
    group_by( orgUnit ) %>% 
    mutate( across( all_of( dataCols$x ) , 

                                ~clean_ts( . ,
                      interpolate = FALSE ,
                      .clean = "MAD" ,
                      MAD = as.numeric( mad() ) # median absolute deviation > 5
                      , .pb = pb
                      )  
                    # , otherwise = NA )
    ) 
           
    ) 
  
  # %>% 
  # 
  #   pivot_longer( {{ dataCols$x }} ,
  #                 names_to =  'vars' ,
  #                 values_to = 'cleanEO' )
  
  # glimpse( dtse )
  print( 'dTs.extreme ... finished' )
  return( dtse )
})

```


```{r dTs.extreme.total , eval=FALSE}

dTs.extreme.total = reactive({
  
  
  dTs.extreme() %>% 
    ungroup() %>%
    summarise( across( all_of(  dataCols$x ) , sum, na.rm = TRUE ) )
  
})

```


```{r plot_mad, eval=FALSE}

plotOutput( 'plot_mad' , 
    click = "plot_mad_click" ,
    dblclick = "plot_mad_dblclick" ,
    hover = "plot_mad_hover" ,
    brush = "plot_mad_brush" )

plot_mad = reactive({
  
  if ( !is.character( dataCols$x ) ) return()
  
  g = ggplot( dTs.extreme.total() %>% 
                pivot_longer( dataCols$x  ,
                  names_to =  'vars' ,
                  values_to = 'cleanEO' ) ,
              aes( x = period , y = cleanEO ) ) +
    facet_wrap( ~ vars , scales = 'free' ) +
    geom_line()

  return(g)
})

output$plot_mad <- renderPlot({  plot_mad()  })
```

Row
-------------------------------------

### STL Outliers 

```{r dTs.stl , eval=FALSE}


pb = NULL
# pb <- progress_bar$new( 
#     format = ":current :percent  [:bar] :elapsedfull",
#     total = .total() , clear = FALSE, width= 50 )

mad = reactive({ input$mad })

dTs.stl = reactive({ 
  
  print( 'dTs.stl ... ' )

  dtsstl =  
    dTs.extreme() %>% 
    filter( orgUnit %in% unique( dTs.extreme()$orgUnit )[] ) %>%
    group_by( orgUnit ) %>% 
    mutate( across( all_of( dataCols$x ) , 

            ~clean_ts( . ,
                      interpolate = FALSE ,
                      .clean = 'tsclean' ,
                      MAD = as.numeric( mad() ) # median absolute deviation > 5
                      , .pb = pb
                      )  
                    # , otherwise = NA )
    ) 
    )
  
  # glimpse( dtsstl )
  print( 'dTs.stl ... finished' )
  return( dtsstl )
})

```


```{r dTs.stl.total , eval=FALSE}

dTs.stl.total = reactive({
  
  
  dTs.stl() %>% 
    ungroup() %>%
    summarise( across( all_of(  dataCols$x ) , sum, na.rm = TRUE ) )
  
})

```


```{r plot_dTs.stl , eval=FALSE}

plotOutput( 'plot_dTs.stl' , 
    click = "plot_dTs.stl_click" ,
    dblclick = "plot_dTs.stl_dblclick" ,
    hover = "plot_dTs.stl_hover" ,
    brush = "plot_dTs.stl_brush" )

plot_dTs.stl = reactive({
  
  if ( !is.character( dataCols$x ) ) return()
  
  g = ggplot( dTs.stl.total() %>% 
                pivot_longer( dataCols$x  ,
                  names_to =  'vars' ,
                  values_to = 'cleanEO' ) ,
              aes( x = period , y = cleanEO ) ) +
    facet_wrap( ~ vars , scales = 'free' ) +
    geom_line()

  return(g)
})

output$plot_dTs.stl <- renderPlot({  plot_dTs.stl()  })
```


Facilities 
====================================

```{r dataTable}
                      
DTOutput( 'dataTable'   ) 



tableData = reactive({
  req( data.total() )
  
  .period = period()
  key.cols = setdiff( group_by_cols() , .period )
  print( "tableData key.cols: ")
  print( key.cols )
  
  print( 'data for table' )
  print( names( data.total() ))
  
  td = data.total() %>% as_tibble() %>%  
    ungroup %>% 
    # select(-Month)  %>% 
    group_by( across( all_of(  {{key.cols}} ) ) ) %>%
    # group_by( orgUnit, dataSet, Zone, District, Facility  ) %>%
    summarise( n = n() )
    
  return( td )
  
})

output$dataTable <- DT::renderDT(
    datatable(
      tableData() , 
      filter = 'top' ,
      extensions = 'Buttons', 
      options = list(
        initComplete = JS(
            "function(settings, json) {",
            "$(this.api().table().header()).css({'background-color': '#0894e5', 
      'color': '#000000'});",
            "}"),
      pageLength = 100,
      scrollY = "400px" ,
      dom = 'Bfrtip',
      buttons = 
        list('copy', 'print', list(
        extend = 'collection',
        buttons = c('csv', 'excel', 'pdf'),
        text = 'Download'
      ))

  )
          )
)


```

### Significance Testing

Trend / Evaluation 
====================================

Row {data-height=350}
-------------------------------------

### Intervention Date

```{r}

# selectInput("filter_data", label = "Filter data:" , 
#               choices = NULL , 
#               selected = NULL  ) 

dates = reactive({ 
    req( dataset() )
    print('dates():'); 
    .period = period()
    dates = dataset() %>% pull( !! rlang::sym( .period )) %>% 
      unique 
    
    # print( dates )
    print( max( dates ))
    print( 'end dates()')
    return( dates )
    
    })


selectInput("evaluation_month", label = "Starting evaluation:" , 
              choices = NULL , 
              selected = NULL,
            selectize = FALSE ,
            size = 4 ) 

div(id = "expr-container",
selectInput("horizon", label = "Number periods after intervention:" , 
              choices = c(3,6,12,18,24,36) , 
              selected = 12 ,
            selectize = FALSE ,
            size = 4 ) 
)


```

### Forecast Type

```{r}

# selectInput("filter_display", label = "Filter display:" , 
#               choices = NULL , 
#               selected = NULL  ) 


checkboxInput( "smooth" , label ='Show smoothed trend line (loess)',
               value = FALSE  ) 

checkboxInput( "pre_evaluation" , label ='Pre-intervention model fit',
               value = FALSE  ) 


checkboxInput( "evaluation" , label ='Post-intervention evaluation',
               value = FALSE  ) 

# checkboxInput( "scale" , label ='Scale values (x-mean)/sd + 1)',
#                value = FALSE  ) 

checkboxInput('components', label = 'Visualize trend' ,
            value = FALSE )

checkboxInput( "forecast_ci" , label ='Confidence interval',
               value = FALSE  ) 


```


### Model Details

```{r}


selectInput("model", label = "Time-series model:" , 
              choices = c('ETS' , 'ARIMA', 'BSTS' , 'Prophet', 
                          'TSLM', 'TSLM (trend)', 
                          'TSLM (trend+season)') , 
              selected = 'ETS'  ) 



# checkboxInput('reconcile', label = 'Reconcile models' ,
#             value = FALSE )

# selectInput("transform", label = "Transformation:" , 
#               choices = c('None', 'Log', 'Box-Cox(.5)', 
#                           'Box-Cox(auto)') , 
#               selected = 'None'  ) 


textInput('model.formula', 'Model Formula' ,
          value =  'total ~ 1' )

textInput('covariates', 'Model covariates' ,
          value =  NULL )

```

### Administrative Hierarchy

```{r adm_hierarchies_1}


selectInput("agg_level", label = "Aggregate to" , 
              choices = NULL , 
              selected = 1  ) 


checkboxInput( "facet_admin" , label ="Facet by admin",
               value = FALSE  )

checkboxInput( "selected" , label ='Selected facilities only',
               value = TRUE  ) 


checkboxInput( "legend" , label ='Show legend',
               value = FALSE  ) 

checkboxInput( "plotly" , label ='Plotly Chart',
               value = FALSE  ) 


```

```{r adm_hierarchies_2}



observe({  updateSelectInput( session, 'agg_level' , 
                              choices = levelNames() , 
                              selected = levelNames()[1] ) # 12 months before latest date
  } )


observe({  updateSelectInput( session, 'level2' ,
                              choices = 
                                dataset() %>% 
                                  pull( !! rlang::sym( levelNames()[2]  ) ) %>% 
                                  unique %>% str_sort(),
                              selected = NULL 
                              ) 
  } )

observe({  updateSelectInput( session, 'level3' ,
                              choices = 
                                dataset() %>% 
                                  filter(
                                  !! rlang::sym( levelNames()[2] ) %in% input$level2 ) %>% 
                                  pull( !! rlang::sym( levelNames()[3]  ) ) %>% 
                                  unique %>% str_sort() ,
                              selected = NULL 
                              ) 
  } )

observe({  updateSelectInput( session, 'level4' ,
                              choices = 
                                dataset() %>% 
                                  filter(
                                  !! rlang::sym( levelNames()[3] ) %in% input$level3 ) %>% 
                                  pull( !! rlang::sym( levelNames()[4]  ) ) %>% 
                                          unique %>% str_sort(),
                              selected = NULL 
                              ) 
  } )

level5 = reactive({
    req( input$level4 )
    req( levelNames() )
    if( is.na( levelNames()[5] ) ) return( NA ) 

    dataset() %>% 
        filter(
            !! rlang::sym( levelNames()[4] ) %in% 
                       input$level4 ) %>% 
        pull( !! rlang::sym( levelNames()[5]  ) ) %>% 
        unique %>% str_sort()  
})

observe({  updateSelectInput( session, 'level5' ,
                              choices = level5(),
          selected = NULL 
)
                                  
  } )


admin_names = function( level = NULL ){
  admin_names = ous() %>% 
    as_tibble %>%
    filter( levelName %in% level ) %>%
    distinct( name , orgUnit ) %>%
    arrange( name )
  print( 'sub_admins'); print( admin_names )
  return( admin_names )
}


```


Row {data-height=650}
-------------------------------------


### Impact (plot_trends)

```{r model_functions}

# conditionalPanel( "input.plotly == true" ,
                  # plotlyOutput( "plotly_trends" ) 
# )

# conditionalPanel( "input.plotly == false" , 
                 plotOutput( "plot_trends" ,
                             hover = "plot_hover"  )
                 # ) 
# selectInput( "var_y", "Y-Axis", choices = NULL )
# uiOutput( "dynamic" )

observe({  
  updateSelectInput( session, 'var_y' ,
          choices =  names( trendData() ) 
          )
  } )

observeEvent(  dates() , {  
  updateSelectInput( session, 'evaluation_month' ,
          choices =  dates()  , 
          selected = dates()[ round(length(dates())/2) ]
            # ifelse( period() %in% 'Month' , 
            #                  dates()[12], 
            #                  dates()[52] )
                             # length(  dates()  ) - 12  ,
                             # length(  dates()  ) - 12            )
                             )
  } )
            

observeEvent(
  input$split  , 
  
  { 
  if ( !input$split %in% 'None' ){
    
    print( "input$split:" ); print( input$split )
    # print( "data.total():" ); # glimpse( data.total() )
    
    # splits = data.total() %>% pull( .data[[ input$split ]] ) %>% unique
    
    splits = data.total()[, input$split] %>% unique
    
    print( paste( 'splits: ', splits  ) )

    updateSelectInput( session, 'filter_data' , choices =  c( 'All', splits ) )
    
    updateSelectInput( session, 'filter_display' , choices =  c( 'All', splits ) )
  
  } else {
    
    updateSelectInput( session, 'filter_data' , choices =  c( 'All' ) )
    updateSelectInput( session, 'filter_display' , choices =  c( 'All' ) )
  }
} )

backtick <- function(x) paste0("`", x, "`")

sub_agg_level = reactive({
  levels() %>%
     mutate( parent = dplyr::lag( levelName ) ) %>%
     filter( parent == input$agg_level ) %>%
     pull( levelName )
})
  

MAPE = reactive({
  req( tsPreForecast() ) 
  print('MAPE')
  predicted = tsPreForecast() %>% as_tibble() %>% select(-total)
  actual =  trendData() 
  d = predicted %>%
     inner_join( actual , by = period() ) 
 
  e = d %>% as_tibble() %>%
        # group_by( orgUnit , data  )  %>%
        summarise( 
          mape = ifelse( mean( total , na.rm = T ) > 0 ,
                       mean( abs( total - .mean ) , na.rm = T ) / 
                       mean( total , na.rm = T ) ,
                       NA ) 
                   ) 
  print( "MAPE"); print( e$mape)
  return( scales::percent( e$mape )  )
  
})


key.mape = reactive({
  req( tsPreForecast() ) 
  req( trendData() ) 
  
  print('key.mape')
  
  predicted = tsPreForecast() %>% 
    rename( pred = .mean ) 
  
  actual =  trendData() %>% 
    rename( actual = total )
  
  keyvars = key_vars( actual )
  print('keyvars'); print( keyvars )
  
  truth = predicted %>% 
     inner_join( actual , by = c( period() , keyvars  ) )  
  
  print( 'truth'); #print( truth )
  
  mid_point = round( as.integer( input$horizon ) /2  )
  
  e = truth %>%
    group_by_key() %>%
    index_by( 1 ) %>%
    summarise( 
          mape = ifelse( mean( pred , na.rm = T ) > 0 ,
                       mean( abs( actual - pred ) , 
                             na.rm = T ) / 
                       mean( pred , na.rm = T ) ,
                       NA ) ,
          !! rlang::sym( period() )  := nth( !! rlang::sym( period() )  , mid_point ) ,
          actual = ifelse( mape>=0 , max( actual, na.rm = TRUE ),
                           min( actual, na.rm = TRUE  ) 
                           #nth( actual , mid_point ) 
          ) ,
          just = ifelse( mape >= 0 , 2, -2 )
          ) %>%
  as_tibble() %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
  print( "end key.mape"); #glimpse(e )
  return( e )
})

MPE = reactive({
  req( tsForecast() ) 

  print('MPE')
  
  predicted = tsForecast() %>% as_tibble() %>% select(-total)
  actual =  trendData() 
  
  d = predicted %>%
     inner_join( actual , by = period() ) 
 
  e = d %>% as_tibble() %>%
        # group_by( orgUnit , data  )  %>%
        summarise( 
          mpe = ifelse( mean( .mean , na.rm = T ) > 0 ,
                       mean(  total - .mean  , na.rm = T ) / 
                       mean( .mean , na.rm = T ) ,
                       NA ) 
                   ) 
  
  print( "MPE"); print( e$mpe)
  return( scales::percent( e$mpe )  )
  
})

key.mpe = reactive({
  req( tsForecast() ) 
  req( trendData() ) 
  
  print('key.mpe')
  
  predicted = tsForecast() %>% 
    rename( pred = .mean ) 
  
  actual =  trendData() %>% 
    rename( actual = total )
  
  keyvars = key_vars( actual )
  print('keyvars'); print( keyvars )
  
  truth = predicted %>% 
     inner_join( actual , by = c( period(), keyvars  ) )  
  
  print( 'truth'); #print( truth )
  
  mid_point = round( as.integer( input$horizon ) /2  )
  
  e = truth %>%
    group_by_key() %>%
    index_by( 1 ) %>%
    summarise( 
          mpe = ifelse( mean( pred , na.rm = T ) > 0 ,
                       mean( actual - pred  , na.rm = T ) / 
                       mean( pred , na.rm = T ) ,
                       NA ) ,
          !! period()   := nth( !! rlang::sym( period() )  , mid_point ) , 
           actual = ifelse( mpe>=0 , max( actual, na.rm = TRUE ),
                           min( actual, na.rm = TRUE  ) 
                           #nth( actual , mid_point ) 
          ) ,
          just = ifelse( mpe >= 0 , 1, -1 )
          ) %>%
  as_tibble()  %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
  print( "mpe"); #glimpse(e )
  return( e )
})

ci_levels = reactive({
  if ( ! input$forecast_ci ) return( NULL )
  return( 90 )
})

```


```{r trendData }
trendData = reactive({
  req( data.hts() )
  # req( aggregatePlotData() )
  print( 'trendData(): ' )
  
  .d = data.hts()
  
  if (input$selected & num_facilities() > 1 ){
    .d = .d %>% filter( 
      Selected ==  'Reporting Each Period' )
    
    if ( period() %in% 'Month' ){ 
      .d = .d %>% filter( 
        Month >=  yearmonth( input$startingMonth )   ,
        Month <= yearmonth( input$endingMonth )  )
    }
      
    if ( period() %in% 'Week' ){ 
      .d = .d %>% filter( 
        Week >=  yearweek( input$startingMonth )   ,
        Week <= yearweek( input$endingMonth )  )
    }
  } 
    
  print( "input$agg_level:" ); print( input$agg_level )


  print( "sub_agg_level:" ); print( sub_agg_level() )
   
  # .d = data.hts() %>% 
  #     filter( 
  #       ! is.na( !! rlang::sym( levelNames()[1] ) )
  #       , is_aggregated( !! rlang::sym( levelNames()[1] ) )
  #     ) 
  
  sub_agg = sub_agg_level() 
  print( 'sub agg level filter' ) ; print( sub_agg )
  
  .d = .d %>% 
      filter( 
        ! is.na( !! rlang::sym( input$agg_level   ) ) 
        # next line is good for level 0
        , ! is_aggregated(  !! rlang::sym( input$agg_level   ) )
      )
  
  print( '!is_empty(sub_agg)' ); 
  print( sub_agg )
  print(!is_empty(sub_agg)); 
  print( class( sub_agg ));
  if ( !is_empty(sub_agg) ){
    print( 'filtering by sub_agg' )
    .d = .d %>% filter( 
          is_aggregated( !! rlang::sym( sub_agg  ) )
    )
  }
    
    .d = .d %>%
       mutate( 
         grouping_var = 'Total' ) %>%
      fill_gaps( .full = TRUE  )

     
     print( '.d in trendData' ); # glimpse(.d)
     
     if ( num_datasets() > 1 ){
       .d = .d %>%
       filter( !is_aggregated( dataSet ) ) %>%
       mutate( dataSet = as.character( dataSet ) %>%
           str_remove_all( "<aggregated>" ) ,
           grouping_var = dataSet )

     }

     if ( num_facilities() > 1 ){
       .d = .d %>%
       filter( !is_aggregated( Selected )  ) %>%
       mutate( Selected = as.character( Selected ) %>%
           str_remove_all( "<aggregated>" )  )

       print( 'Facilities:') ; print( unique(.d$Selected))
     }
        
    # if split, remove aggregate grouping
     if ( !input$split %in% 'None' ){
       print( 'input split:') ; print( input$split )
       .d = .d %>%
         filter( !is_aggregated( !! rlang::sym( input$split ) ) 
         ) %>%
         mutate( grouping_var = as.character( 
           !! rlang::sym( input$split ) )
         )
       print( '.d  aggregated split'); 
       print( unique(.d$grouping_var) )
       # print( glimpse( .d ))
       
     } 

  print( 'nrow(.d)'); print(nrow(.d))
     
    # if ( !input$split %in% 'None' & !input$filter_data %in% 'All' ){
    #     print( 'filter_data is not null' )
    #     .d = .d %>% 
    #       filter( .data[[ input$split ]] %in% input$filter_data )
    # }
  
  # if ( input$scale ) .d = .d %>% 
  #     ungroup() %>%
  #     mutate( 
  #       total = scale( total ) + 1
  #   )
  
  print( 'end trend data():'); # print( glimpse( .d ) ); # print(.d)

  
  return( .d )
})
```


```{r models_forecasts}
evaluationParameters <- reactiveValues( Month  = NULL )

model_formula = reactive({
  req( input$model.formula )
  print( 'model_formula' )

    
  # if (input$model %in% 'BSTS'){
  #   f = as.formula( 'total ~ intercept()' ) 
  #   
  # } 
  
  if (input$model %in% 'ARIMA' ){
    formula.string = paste( 'fabletools::box_cox( total , lambda = .5  ) ~ ',
                            ' pdq() ' ,  
                            '+ PDQ( period = 12 )' 
    )
     if ( nchar( input$covariates ) > 0 ) formula.string = 
         paste( formula.string , '+ xreg(' , input$covariates , ' ) ' )
     
     f = as.formula( formula.string)
  }
  
  if (input$model %in% 'BSTS' ){
     f = as.formula( paste( 'total ~ season("year")' 
                       )
     )
     }
                     
   if ( any(input$model %in% c( 'TSLM', 'ETS',  'Prophet' ) ) ){
      
    f = as.formula(  input$model.formula )

    }

  print( 'end model_formula' ); print( f )
  return( f )
})

tsModel = reactive({
  req( trendData() )
  req( model_formula() )
  req( input$evaluation_month )
  
  if ( !input$evaluation ) return( NULL )
  print( 'tsModel():' )
  print( paste('available vars:', 
               paste( names(trendData()), collapse = ',') 
               )
  )
  
  # Filter data to period just before evaluation start
  print( input$evaluation_month )
  eval_month = input$evaluation_month
  time_period = yearmonth( eval_month  ) # - month(1)
  
  fit.data  = trendData() %>%
    filter_index( ~ as.character( time_period ) ,
                  .preserve = TRUE )
  
  if (input$model %in% 'TSLM' ){
    fit = fit.data %>% model( l = TSLM( model_formula() ) ) 
    print( 'end tsModel():' )
    return( fit )
    } 
  
  if (input$model %in% 'TSLM (trend)' ){
    fit = fit.data %>% model( l = TSLM( total ~ trend()  ) )
    print( 'end tsModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'TSLM (trend+season)' ){
    fit = fit.data %>% model( l = TSLM( total ~ trend() + season() ) )
    print( 'end tsModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'ARIMA' ){
    fit = fit.data %>% model( 
      arima = ARIMA( model_formula()  )
      )    
  # if ( input$reconcile ) fit = fit %>% 
  #       reconcile( 
  #         mint = min_trace(a, method = "mint_shrink") 
  #         )
    print( 'end tsModel(): arima fit' )
    glimpse( fit )
    # testing model fit for forecasts
    if ( input$covariates %in% c('ipti', 'doses') ) saveRDS( fit , 'arima.rds' )
    return( fit )
  } 
  
  if (input$model %in% 'BSTS' ){
    fit = fit.data %>% model( b = BSTS( model_formula() ) )
    print( 'end tsModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'ETS' ){
    fit = fit.data %>% model( a = ETS( total )  ) 
    
    print('ETS model') ; #print( fit )
    
  # if ( input$reconcile ) fit = fit %>% 
  #       reconcile( 
  #         mint = min_trace(a, method = "mint_shrink") 
  #         )
    print( 'end tsModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'Prophet' ){
    fit =  fit.data %>% model( 
            prophet = prophet( total ~

                                    growth( type = 'linear',
                                            changepoint_range = 1 ,
                                            changepoint_prior_scale = 1 ,
                                            # capacity = 1e5 ,
                                            # floor = 0 
                                            ) +
                                    season(period=12, 
                                           order = 4 ,
                                           type='multiplicative'),
                               seed = TRUE ,
                               future.seed=TRUE )
        )
   
    print( 'end tsModel():' )
    return( fit )
  } 
  
})

tsPreModel = reactive({
  req( trendData() )
  req( input$evaluation_month )

  if ( !input$pre_evaluation ) return( NULL )
  print( 'tsPreModel():' )

  eval_month = input$evaluation_month 
  time_period = yearmonth( eval_month  ) - 12
  
  fit.data  = trendData() %>%
    filter_index( ~ as.character( time_period ) ,
                  .preserve = TRUE )
  
    if (input$model %in% 'TSLM' ){
    fit = fit.data %>% model( l = TSLM( model_formula() ) ) 
    print( 'end tsPreModel():' )
    return( fit )
    } 
  
  if (input$model %in% 'TSLM (trend)' ){
    fit = fit.data %>% model( l = TSLM( total ~ trend()  ) )
    print( 'end tsPreModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'TSLM (trend+season)' ){
    fit = fit.data %>% model( l = TSLM( total ~ trend() + season() ) )
    print( 'end tsPreModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'ARIMA' ){
    fit = fit.data %>% model( 
      arima = ARIMA( model_formula()  )
      )    
    print( 'end tsPreModel(): arima fit' )
    return( fit )
  } 
  
  if (input$model %in% 'BSTS' ){
    fit = fit.data %>% model( b = BSTS( model_formula() ) )
    print( 'end tsPreModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'ETS' ){
    fit = fit.data %>% model( a = ETS( total )  ) 
    
    print('ETS model') ; #print( fit )
    
  # if ( input$reconcile ) fit = fit %>% 
  #       reconcile( 
  #         mint = min_trace(a, method = "mint_shrink") 
  #         )
    print( 'end tsPreModel():' )
    return( fit )
  } 
  
  if (input$model %in% 'Prophet' ){
    fit =  fit.data %>% model( 
            prophet = prophet( total ~

                                    growth( type = 'linear',
                                            changepoint_range = 1 ,
                                            changepoint_prior_scale = 1 ,
                                            # capacity = 1e5 ,
                                            # floor = 0 
                                            ) +
                                    season(period=12, 
                                           order = 4 ,
                                           type='multiplicative'),
                               seed = TRUE ,
                               future.seed=TRUE )
        )
   
    print( 'end tsPreModel():' )
    return( fit )
  } 
  
})

tsForecast = reactive({ 
  
  req( tsModel() ) 
  req( input$horizon )
  print( 'tsForecast()' )
  
  if ( input$bootstrap ){
    
    fcast = tsModel() %>% 
      forecast( h = as.numeric( input$horizon ) ,
                bootstrap = TRUE, 
                times = as.integer( input$Reps ) 
      )
  } else {
    fcast = tsModel() %>%
      forecast( h = as.numeric( input$horizon ) ) 
  }
  
  fcast = fcast %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
  print( 'fcast:' );  #glimpse( fcast )
  return( fcast )
  })

tsPreForecast = reactive({ 
  
  req( tsPreModel() ) 
  req( input$horizon )
  
  fcast = tsPreModel() %>% forecast( h = 12 )
  
  fcast = fcast %>%
      mutate( !! input$agg_level := 
                as.character( !! rlang::sym( input$agg_level  ) ) )
  
    
  # print( 'pre-fcast' ) ; print( fcast )
  return( fcast )
  })

```

```{r plot_trends}
plotTrends = reactive({
  
  req( trendData() )
  req( input$split )
  # req( input$evaluation_month )
  print( 'plotTrends():' )

  .limits =
  # if ( input$scale ){
  #   c( NA , NA ) } else {
      c( 0 , NA ) 
  # }
 
  data.text = paste( unique( plotData()$data ), collapse = " + " )
  
  .d = trendData() 
  print( 'ploTrends .d:'); #glimpse(.d)
  
  # if ( !input$filter_display %in% 'All' ) .d = .d %>% 
  #         filter( .data[[ input$split ]] %in%
  #                   input$filter_display )

  tic() 
  g = .d %>%
  autoplot( total ) +
    # ggplot( aes(x = Month, y = total
    #          , group = grouping_var
    #          , color =  grouping_var
    #         ) )  +
    # geom_line() +
  theme_minimal() 
  save(.d, file = 'plot-trend-test-data.rda')
  # TESTING: 
  
  
  print( 'basic plot done' ); toc()
  
  if ( !input$legend ) g = g + 
    theme(legend.position = "none")
  
  if ( !input$split %in% 'None' ){ 
    g = g + geom_label_repel( 
               data = .d %>% filter( Month == max( .d$Month , na.rm = T )) ,
               aes( label = grouping_var , group = grouping_var )
               )
  }
  
  # Determine number of agg levels available
  # If only one, do not facet (causes error, perhaps because of autoplot?)
  
  num_agg_levels = count( .d %>% as_tibble , 
                          !! rlang::sym( input$agg_level ) ) %>%
    nrow()

  # if ( input$agg_level != levelNames()[1] & input$facet_admin ){
  if ( num_agg_levels  > 1 & input$facet_admin ){
    print( 'facets' )
    g = g +
    facet_wrap( vars(!! rlang::sym( input$agg_level ) ) ,
                   scales = "free_y" )
  }
  
  g = g +

    scale_x_yearmonth("", date_breaks="1 year" ) +
    scale_y_continuous( label=comma, limits = .limits ) +
    scale_color_discrete( drop = TRUE  ) +
    labs( y = "" , x="" ,
          title = str_wrap( input$indicator , 200 ) ,
          subtitle = str_wrap( data.text , 200 ) 
          , caption =  str_wrap( caption.text() , 200 )
          ) 
  print( 'axis scales and labs done' )
  
  #### Evaluation Trend Line
  if ( input$evaluation ){
    print( 'evaluation line ' )
    eval_date =   yearmonth( input$evaluation_month  ) 
    
   g = g + 
    autolayer( tsForecast()
               , level = ci_levels()
               , color = 'black'
               , linetype = 'dashed', size = 1
               ,  alpha = .5 ) +
     
    # geom_line( data = tsForecast() %>%
    #   as_tibble %>%
    #   mutate( !! input$agg_level := as.character( !! rlang::sym( input$agg_level  ) ) ) ,
    #            aes( x = Month, y = .mean ) ,
    #            color = 'blue' , alpha = .5 ) 
    geom_vline( xintercept = as.Date( eval_date ) ,
                color = 'black', alpha = 1 ) +
    # annotate( "text" ,
    #           x = as.Date( eval_date ) ,
    #           y = Inf ,
    #           hjust = 0 , vjust = 1 ,
    #           label = paste( "MPE:\n" )
    #           ) +
    geom_label_repel( data =  key.mpe() ,
               aes(  x = !! rlang::sym( period() ) , y = actual , 
               label = paste( "MPE:" , percent( mpe, accuracy = 1.0 ) ) ,
               hjust = just 
               ) ,
               # force_pull = 0 , 
               segment.colour = NA
               )
  }
  
  print( 'evaluation line done' )

  ### Pre-Evaluation trend line
  if ( input$pre_evaluation ){
    
    print( 'pre evaluation line ' )
    pre_eval_date = yearmonth( input$evaluation_month  ) - 12
        # month( as.integer( input$horizon ) )
      
    print( 'pre_eval_date is' ); print( pre_eval_date )
    g = g + 
    autolayer( tsPreForecast()
               , level = ci_levels()
               , color = 'black' 
               , linetype = 'dotted'  , size = 1
               ,  alpha = .5 ) +
    # geom_line( data = tsPreForecast(), aes( y = .mean ) ,   color = 'light blue', alpha = 1 ) +
    geom_vline( xintercept = as.Date( pre_eval_date ) ,
                color = 'brown' ,
                alpha = .25 ) +
    # annotate( "text" ,
    #           x =  as.Date( pre_eval_date ) ,
    #           y = Inf ,
    #           hjust = 0 , vjust = 1 ,
    #           label = paste( "MAPE:"  )
    #           ) +
    geom_label_repel( data =  key.mape() ,
               aes(  x = !! rlang::sym( period() ) , y = actual , 
               label = paste( "MAPE:" , percent( mape, accuracy = 1.0 ) ) ,
               hjust = just ) ,
               # force_pull = 0 , 
               segment.colour = NA 
               )

  }
  
  print( 'pre-evaluation line done' )
   
  if (input$smooth){
    print( 'agg level' ); print( input$agg_level )
    .d. = .d %>% 
      as_tibble %>%
      mutate( !! input$agg_level := as.character( !! rlang::sym( input$agg_level  ) ) )
    
    print( 'smooth .d.') ; #glimpse(.d. )
    g = g + 
    geom_smooth( data = .d. , 
                 alpha = .75 )
  
  } 
  
  # Confidence Interval
  # if ( input$forecast_ci & input$evaluation ){
  #   print( 'confidence intervals line ' )
  #   fbl = tsForecast() 
  #   print( 'glimpse fbl') ; # glimpse( fbl )
  #   ci = fbl %>% 
  #     mutate( hilo = hilo( total , 80 ) )
  #   ci$.lower = ci$hilo$lower 
  #   ci$.upper = ci$hilo$upper 
  #   print( 'glimpse ci') ; # glimpse( ci )
  #   
  #   print( 'summary lower') ; print( summary( ci$.lower ) )
  #   print( 'summary upper') ; print( summary( ci$.upper ) )
  #   
  #   g = g + 
  #     geom_ribbon(  data = ci , 
  #       color = 'blue' , alpha = .5 , 
  #       # fill = 'blue' , 
  #       inherit.aes = FALSE ,
  #       aes( x = Month, ymin = .lower, ymax = .upper )
  #            # ymin = .mean, 
  #            # ymax = .mean 
  #            # )
  #   )
  #   return( g )
  # } 
  #   
  print( 'end plotTrends():' )
  
  return( g )
})


# output$plotly_trends <- renderPlotly({
#   plotly::ggplotly( plotTrends() )  })
 
```

```{r plot_model_components}
plotComponenets = reactive({
  
  req( tsModel() )
  req( input$evaluation_month )
  print( 'plotComponenets():' )

  g = tsModel() %>% fabletools::components() %>% autoplot
  
  print( 'end plotComponents():' )
  
  return( g )
})


# output$plotly_trends <- renderPlotly({
#   plotly::ggplotly( plotTrends() )  })
 
```

```{r trend_output}

plotTrendOutput = reactive({
    if ( input$components ){
        plotComponenets()  
    } else {
        plotTrends()  
    }
})

output$plot_trends <-  renderPlot({ plotTrendOutput()  })
        

output$dynamic <- renderUI({
    req(input$plot_hover) 
    verbatimTextOutput("vals")
  })

output$vals <- renderPrint({
    hover <- input$plot_hover 
    # print(str(hover)) # list
    y <- nearPoints( trendData() , input$plot_hover)[input$var_y]
    req(nrow(y) != 0)
    y
  })

```

Significance Testing
====================================

Row {data-height=350}
-------------------------------------

### Model parameters

```{r}
checkboxInput( "bootstrap" , label ='Bootstrap prediction',
               value = TRUE  ) 

selectInput("Reps", label = "Iterations" , 
              choices = c(100, 1000, 5000, 10000) , 
              selected = 100  ) 

# textInput( 'model_text' , label = 'Model' , value = NULL )

```



```{r significance_functions}

forecast_distribution = function( forecast, var ){
    if ( ! "fbl_ts" %in% class( forecast ) ) cat("missing fbl_ts")
    
    # get components 
    var = enquo( var )
    r = forecast %>% pull( {{var}} )
    dist <- map( r, "dist")
    trans <- map( r, "transform")

    # generate 
    gt = map( 1:length(r), ~{
    t = trans[[.x]]
    g = generate( dist[[.x]] ) %>% t 
    return(g)
    }  ) %>% unlist

    # differnece between forecast and actual
    t = map( forecast$value, "transform")[[1]]
    rd = forecast %>% 
        mutate(
        dist = map( {{var}}, "dist") ,
        # trans = map( value, "transform") ,
        .fore = map( dist, ~generate(.x) %>% t ) ,
) 
}

# Difference over each iteration, which is naturally wieghted
mpe_distribution = function( forecast_distribution , var ){
    
    var = enquo( var )
    
    index = tsibble::index( forecast_distribution )
    
    forecast_distribution %>%
    unnest( .fore ) %>% 
    group_by( {{ index }} ) %>%
    mutate( n = row_number() ,
            .fore = ifelse( is.na( {{var}}), NA, .fore ) 
            ) %>%
    group_by( n ) %>%
    summarise( 
        actual = sum( {{var}}, na.rm = T ) ,
        .fore = sum( .fore , na.rm = T) 
        ) %>%
    ungroup() %>%
    mutate( mpe = ( actual- .fore )/ .fore ,
            mape = abs( actual- .fore )/ .fore ) 
}

# function to get probability than impact, e, greater than a value
prb_change_lte = function( target_mpe , pe ){
   pe = enquo( pe )
   
   mpe %>%
     summarise(
       n = sum( !is.na( {{pe}} ) ) ,
       pe_lte_target = sum( {{pe}} <= target_mpe ) 
     ) %>%
     mutate( x = pe_lte_target / n ) %>%
     pull( x )
   
}

# plot error
mpe_plot = function( .data , var, rope_range  = NULL   ){
   var = enquo( var )
   
   me = .data %>% pull({{ var }})
   
   mean_me = mean( me , na.rm = T )
   
   cri = HDInterval::hdi( me , credMass = 0.9 ) %>% as.numeric()
   cri_label = paste( '90% credible interval:\n[', 
                      percent(cri[1], accuracy  = .1 ) , " - ", 
                      percent(cri[2] , accuracy  = .1 ) , "]" , sep = "" )
   
   mpe_rope = rope( me , range =  rope_range )
   mpe_rope_label = paste( 'Probabality in ROPE*\n [', 
                           percent( rope_range[1], accuracy = .1 ) , "-" , 
                           percent( rope_range[2] , accuracy = .1) , ']:', 
                           percent( mpe_rope$ROPE_Percentage , accuracy = .1 ) )
   
   # Title text...
   # if ( "mpe" %in%  var )
  
  g = 
    ggplot( data = .data , aes( x = {{ var }} )) +
    geom_histogram( aes(  y = ..count../sum(..count..) ) ,
                    fill = 'dark gray', color = 'gray', binwidth = .01 ) +
    theme_minimal() +
    scale_x_continuous( labels = percent_format(accuracy = 1) , 
                        breaks = seq(-1, 1, .1) ) +
    labs( title = 'Posterior Distribution of Error' ,
          # subtitle = {{ var }} ,
          y = 'Probability' 
          # x = {{ var }} ,
          # , caption = "*Region of Practical Equivalence"
          )

  # add mean
  g = g + 
    # geom_vline( aes( xintercept = mean(e) ) , linetype = 'dashed' ) +
    annotate( "segment" , x =  mean_me , xend =  mean_me , y = 0 , yend = .1 , 
              color = 'black' , linetype = 'dashed')  + 
    geom_text( aes( x = mean_me ,
                    y = .1  , 
                    label = paste('Mean:' , percent( mean_me , accuracy  = .1 )  ) ) )  +
    
    # cri
    annotate( "segment" , x = cri[1] , xend = cri[1] , y = 0 , yend = .5 , color = 'blue' )  + 
    annotate( "segment" , x = cri[2] , xend = cri[2] , y = 0 , yend = .5 , color = 'blue' )  +
    annotate( "text" , x = cri[1] , y = .4 , color = 'blue', label = cri_label , hjust = - 0.1 ) 
    
    # rope
  if ( !is.null( rope_range ) ) g = g +
    annotate( "segment" , 
              x = mpe_rope$ROPE_low , 
              xend = mpe_rope$ROPE_low , y = 0 , yend = .5 , color = 'brown' )  + 
    annotate( "segment" , 
              x = mpe_rope$ROPE_high , 
              xend = mpe_rope$ROPE_high , y = 0 , yend = .5 , color = 'brown' )  +
    annotate( "text" , x =  0  , y = .5 , color = 'brown', 
              label = mpe_rope_label , hjust = .5 , vjust = 1 )
  
  return( g )
  }
```

Row {data-height=650}
-------------------------------------


```{r  }


sigData = reactive({
  
  req( trendData() )
  req( tsForecast() )
  print( 'sigData():' )
  
  # print( names( trendData() ) ) ; 
  tsf = tsForecast()
  td = trendData()
  
  # testing: 
  # save(tsf, td,  file = 'tsftd.rda' )
  
  # glimpse( tsf ) 
  
  # fd = forecast_distribution( tsf , total )
  # glimpse( fd ) 
  
  cat( 'create forecast_distribution():')
  
    if ( ! "fbl_ts" %in% class( tsf ) ) cat("not a fbl_ts")
    
    # get components 
    r = tsf %>% pull( total )
    
    r.names = map( r, names ) %>% unlist %>% unique
    print( 'forecast_distribution() r.names:' ) ; print( r.names )
      
    if ( 'x' %in% r.names ){
        
       cat( 'forecast_distribution(): x')
      
        # dist <- map( r, "x")
        trans <- map( r, "transform") 

        # differnece between forecast and actual
        fd = tsf %>% 
          mutate(
            dist <- map( total , "x" ) 
            # trans = map( value, "transform") ,
            , .fore = map( dist, ~.x  )
          ) 
        
        print( 'end forecast_distribution(): x')

      }
      
    if ( 'dist' %in% r.names ){
      
      cat( 'forecast_distribution(): dist')
        
        dist <- map( r, "dist")
        trans <- map( r, "transform")
        # generate 
        gt = map( 1:length(r), ~{
          t = trans[[.x]]
          g = generate( dist[[.x]] ) %>% t 
          return(g)
        }  ) %>% unlist
        
        # differnece between forecast and actual
        t = map( forecast$value, "transform")[[1]]
        fd = forecast %>% 
          mutate(
            dist = map( {{var}}, "dist") ,
            # trans = map( value, "transform") ,
            .fore = map( dist, ~generate(.x) %>% t ) ,
          ) 
        
        cat( 'end forecast_distribution(): dist')

      }
  
  print( 'adding actual values' )
  fd$actual = trendData() %>% 
    rename( actual = total ) %>%
    semi_join( fd %>% as_tibble() ) %>% pull( actual )
  
  print( 'forecast distribution'); # glimpse( fd )
  
  print( 'end sigData():' )
  return( fd )
  
})

plotOutput( "plot_significance" )


plotSig = reactive({
  
  print( 'plotSig():')
  
  req( sigData() )
  
  fd = sigData()
  
  cat('plotSig fd:' )
  
  mpe = mpe_distribution( fd , actual )

  cat('plotSig mpe:' )
  
  g =  mpe_plot( mpe , mpe )
  
  
  print( 'end plotSig():')
  return(g)
   
} )
  
 
output$plot_significance <- renderPlot({ plotSig()  }) 

# 
# # fd %>% hilo(95)
# fd$actual = test$value 
# mpe = mpe_distribution( fd, actual )
# mean( mpe$mpe , na.rm = TRUE)
# 
# 
# 
# mpe_plot( mpe, mpe )
# mpe_plot( mpe, mpe , rope_range = c(-.031,.031))
# 
# prb_change_lte( 0 , mpe )
# prb_change_lte( -.1 , mpe )
# rope_range = c(-.03 , .03 ) 
# rope( mpe$mpe , range =  rope_range )





```

